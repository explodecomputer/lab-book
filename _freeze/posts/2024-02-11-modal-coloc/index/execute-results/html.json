{
  "hash": "eb6b3f92384fcae10aa32733c8ed929f",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Modal colocalisation\"\nauthor: Gibran Hemani\ndate: \"2024-02-11\"\ncategories: []\nexecute:\n  eval: false\n---\n\n\n## Background\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(GWASbrewer)\nlibrary(tidyr)\nlibrary(dplyr)\nlibrary(ggplot2)\nlibrary(mrclust)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ndata(\"ld_mat_list\")\ndata(\"AF\")\n\nmake_ld_mat <- function(n, ld_mat_list) {\n\n    ind <- tibble(ind = 1:nrow(ld_mat_list[[1]]), lind = 1:nrow(ld_mat_list[[1]]), i = 1)\n    for(i in 2:length(ld_mat_list)) {\n        ind <- bind_rows(ind, tibble(ind = max(ind$ind) + 1:nrow(ld_mat_list[[i]]), lind = 1:nrow(ld_mat_list[[i]]), i = i))\n    }\n    ind <- ind[ind$ind <= n,]\n    mat <- matrix(0, n, n)\n    for(i1 in 1:length(unique(ind$i))) {\n        d <- subset(ind, i == i1)\n        mat[d$ind[1]:max(d$ind), d$ind[1]:max(d$ind)] <- as.matrix(ld_mat_list[[i1]][d$lind[1]:max(d$lind), d$lind[1]:max(d$lind)])\n    }\n    return(mat)\n}\nldmat <- make_ld_mat(1000, ld_mat_list)\ndim(ldmat)\n\nset.seed(1)\n\nG <- matrix(c(0, sqrt(0.25), 0, sqrt(0.15), \n              0, 0, 0, sqrt(0.1), \n              sqrt(0.2), 0, 0, -sqrt(0.3), \n              0, 0, 0, 0), nrow = 4, byrow = TRUE)\ncolnames(G) <- row.names(G) <- c(\"X\", \"Y\", \"Z\", \"W\")\nG\n\nsim_dat1_LD <- sim_mv(G = G,\n                      J = 1000, \n                      N = 50000, \n                      h2 = c(0.3, 0.3, 0.5, 0.4), \n                      pi = 1/1000, \n                      R_LD = list(ldmat=Matrix(ldmat)), \n                      af = AF)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nb <- inner_join(\n        sim_dat1_LD$beta_hat %>% as_tibble() %>% rename(X=V1, Y=V2, Z=V3, W=V4) %>% mutate(pos=1:n()) %>%\n            pivot_longer(c(\"X\", \"Y\", \"Z\", \"W\")) %>% rename(bhat=value),\n        sim_dat1_LD$se_beta_hat %>% as_tibble() %>% rename(X=V1, Y=V2, Z=V3, W=V4) %>% mutate(pos=1:n()) %>%\n            pivot_longer(c(\"X\", \"Y\", \"Z\", \"W\")) %>% rename(se=value)\n)\nb\n\nbm <- inner_join(\n        sim_dat1_LD$beta_joint %>% as_tibble() %>% mutate(pos=1:n()) %>%\n            pivot_longer(c(\"X\", \"Y\", \"Z\", \"W\")) %>% rename(bhat=value),\n        sim_dat1_LD$se_beta_hat %>% as_tibble() %>% rename(X=V1, Y=V2, Z=V3, W=V4) %>% mutate(pos=1:n()) %>%\n            pivot_longer(c(\"X\", \"Y\", \"Z\", \"W\")) %>% rename(se=value)\n)\nbm\n\nb %>% ggplot(., aes(x=pos, y=bhat)) +\ngeom_point() +\nfacet_grid(name ~ .)\n\nbm %>% ggplot(., aes(x=pos, y=bhat)) +\ngeom_point() +\nfacet_grid(name ~ .)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nbw <- b %>% select(pos, name, bhat) %>% pivot_wider(names_from=c(name), values_from=bhat)\n\nsew <- b %>% select(pos, name, se) %>% pivot_wider(names_from=c(name), values_from=se)\n\npairs(bw[,-1])\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nbeta <- function(BetaIV.in, seBetaIV.in, phi)\n{\n    #Bandwidth rule - modified Silverman's rule proposed by Bickel (2002)\n    s <- 0.9*(min(stats::sd(BetaIV.in), stats::mad(BetaIV.in)))/length(BetaIV.in)^(1/5)\n\n    #Standardised weights\n    weights <- seBetaIV.in^-2/sum(seBetaIV.in^-2)\n\n    beta <- NULL\n\n    for(cur_phi in phi)\n    {\n        #Define the actual bandwidth\n        h <- max(0.00000001, s*cur_phi)\n        #Compute the smoothed empirical density function\n        densityIV <- stats::density(BetaIV.in, weights=weights, bw=h)\n        #Extract the point with the highest density as the point estimate \n        beta[length(beta)+1] <- densityIV$x[densityIV$y==max(densityIV$y)]\n    }\n    return(beta)\n}\n\n\nbiv <- bw$Z / bw$W\nbiv[abs(bw$Z) < 0.01 | abs(bw$Y) < 0.01] <- NA\nplot(biv)\n\nbiv <- bw$W / bw$Z\nbiv[abs(bw$Z) < 0.01 | abs(bw$Y) < 0.01] <- NA\nplot(biv)\n\n\nbiv <- bw$W / bw$X\nbiv[abs(bw$Z) < 0.01 | abs(bw$Y) < 0.01] <- NA\nplot(biv)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nind <- abs(bw$W) > 0.05 | abs(bw$X) > 0.05\npairs(bw[ind,-1])\nbw <- bw[ind,]\nsew <- sew[ind,]\nres_em = mr_clust_em(theta = bw$W/bw$X, theta_se = sew$W/abs(bw$X), bx = bw$X, by = bw$W, bxse = sew$X, byse = sew$Y, obs_names = bw$pos)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nhead(res_em$results$best)\n\nplot.sbp.best = res_em$plots$two_stage + ggplot2::xlim(0, max(abs(bx)+2*bxse)) + ggplot2::xlab(\"Genetic association with SBP\") + ggplot2::ylab(\"Genetic association with CAD\") + ggplot2::ggtitle(\"\")\n\nplot.sbp.best\n```\n:::\n\n\n\nbuild graph\n\nsteiger dir x -> y\n\n\n\n1. get the causal variants across all traits\n2. get conditional on all variants\n3. \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nget_conditional\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nxpx <- t(ldmat) %*% ldmat\nxpx[1:10,1:10]\n\nxpxi <- solve(xpx)\nxpxi[1:10,1:10]\n\npc <- princomp(xpx)\n\nnames(pc)\n\npc$loadings[1:10,1:10]\n\nxe <- eigen(ldmat)\n\nclass(xe)\nxe[[2]][1:10,1:10]\nclass(xe)\n\nx <- tcrossprod(xe$vectors, tcrossprod(xe$vectors, diag(xe$values)))\n\nx[1:10,1:10]\nldmat[1:10,1:10]\n\nrho = t(v)l\n\nrho <- xe$vectors %*% t(xe$vectors %*% diag(xe$values))\ndim(rho)\nrho[1:10,1:10]\n\n\nvi <- solve(xe$vectors)\n```\n:::\n\n\n---\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsessionInfo()\n```\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}