{
  "hash": "987134f3a1b007e394fa551843a7ffbd",
  "result": {
    "markdown": "---\ntitle: \"Genetic confounding as a function of sample size\"\nauthor: Gibran Hemani\ndate: \"2023-05-13\"\ncategories: [MR, genetic confounding]\n---\n\n\n## Background\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(dplyr)\nlibrary(ggplot2)\nlibrary(simulateGP)\nlibrary(dplyr)\nlibrary(TwoSampleMR)\nlibrary(purrr)\nlibrary(pwr)\n```\n:::\n\n\n## Bias from G-U instruments\n\nThis is the expected effect estimate of X on Y using an instrument that arises via U:\n\n$$\n\\beta_{IV,u} = \\frac{\\beta_{gu} \\beta_{uy} + \\beta_{gu} \\beta_{ux} \\beta_{xy}}{\\beta_{gu} \\beta_{ux}}\n$$\n\nwhich simplifies to\n\n$$\n\\beta_{IV,u} = \\frac{\\beta_{uy}}{\\beta_{ux}} + \\beta_{xy}\n$$\n\nCheck that this is correct\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnid <- 10000\ngx <- rbinom(nid, 2, 0.3)\ngu <- rbinom(nid, 2, 0.3)\n\nu <- gu + rnorm(nid)\nxl <- gx + rnorm(nid)\n\nparam <- expand.grid(\n\tbux = seq(-1, 1, by=0.2),\n\tbuy = seq(-1, 1, by=0.2),\n\tbxy = c(0, 0.5)\n) %>% filter(bux != 0, buy != 0)\n\nout <- lapply(1:nrow(param), function(i)\n{\n\tx <- xl + u * param$bux[i]\n\ty <- x * param$bxy[i] + u * param$buy[i] + rnorm(nid)\n\tp <- param[i,]\n\tp$bgx <- get_effs(x, y, matrix(gx, nid, 1)) %>% mr() %>% {.$b}\n\tp$bgu <- get_effs(x, y, matrix(gu, nid, 1)) %>% mr() %>% {.$b}\n\treturn(p)\n}) %>% bind_rows()\n\nout$exp_gu <- out$buy / out$bux + out$bxy\nplot(bgu ~ exp_gu, subset(out, !is.infinite(exp_gu)))\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-2-1.png){width=672}\n:::\n:::\n\n\nSimilarly, the bias in observational studies is\n\n$$\n\\beta_{OLS} = \\beta_{xy} + \\beta_{ux}\\beta_{uy}\n$$\n\n## Bias in MR with heritable confounders\n\nSimulate summary statistics for `nsnpx` causal variants on $x$ and `nsnpu` causal variants on $u$ according to a standard polygenic architecture\n\n$$\n\\beta_{g.} \\sim N(0, [2p(1-p)^S \\sigma^2_g])\n$$\n\nwhere $p$ is the allele frequency, $S$ is the selection coefficient and $\\sigma^2_g$ is a scaling parameter relating to the additive genetic variance. For SNPs that influence $x$ via $u$, the $\\beta_{gx} = \\beta_{gu}\\beta_{ux}$. For varying values of $\\beta_{ux}$ and $\\beta_{uy}$ we can calculate the expected bias in the MR estimate for each SNP as \n\n$$\n$b_{MR,j} \\beta_{g_ju}\\frac{\\beta_{uy}}{\\beta_{ux}}\n$$\n\nAs sample size increases, the probability of inclusion of a SNP from GWAS discovery in the exposure $x$ increases. So the overall bias of an MR estimate, $b_{MR}$ will be the inverse variance weighted contribution of a SNP given it's probability of discovery\n\n$$\nb_{MR} = \\frac{\\sum^{M}_{j=1} \\beta_{g_ju} w_j z_j}{\\sum^{M}_{j=1} w_j z_j}\n$$\n\nwhere $w_j = 1/2p_j(1-p_j)$ and z_j is the power of detection of the SNP at pval < 5e-8 based on its correlation with the trait $r = 2p(1-p)\\beta_{gx}^2$ (assumes variance of x = 1) and for a given sample size.\n\nHere is an example of how\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsimfn2 <- function(nsnpx, nsnpu, bux, buy, nid, h2x, h2u, Sx, Su, bax=1) {\n\targs <- environment() %>% as.list() %>% as_tibble()\n\tmapx <- tibble(snp=paste0(1:nsnpx, \"x\"), af=runif(nsnpx, 0.01, 0.99))\n\tmapu <- tibble(snp=paste0(1:nsnpu, \"u\"), af=runif(nsnpu, 0.01, 0.99))\n\tparamsx <- generate_gwas_params(map=mapx, h2=h2x, S=Sx, Pi=1)\n\tparamsu <- generate_gwas_params(map=mapu, h2=h2u, S=Su, Pi=1)\n\tparams <- rbind(paramsx %>% mutate(beta=beta*bax), paramsu %>% mutate(beta=beta * bux))\n\to <- map(nid, \\(i){\n\t\tssx <- generate_gwas_ss(params, i)\n\t\tssx$beta <- params$beta\n\t\tssx$w <- 1/ssx$se^2\n\t\tssx$bias <- buy/bux\n\t\tssx$bias[grepl(\"x\", ssx$snp)] <- 0\n\t\tssx <- ssx %>% mutate(h2 = beta^2 * 2 * af * (1-af))\n\t\tssx <- ssx %>% arrange(pval)\n\t\tx <- ssx %>%\n\t\t\tmutate(\n\t\t\t\tn=i,\n\t\t\t\tpow = pwr.r.test(n=i, r=sqrt(ssx$h2), sig.level=5e-8)$power,\n\t\t\t\tu_indicator = as.numeric(grepl(\"u\", snp))\n\t\t\t) %>%\n\t\t\tsummarise(\n\t\t\t\tbias = sum(bias * w * pow) / sum(w * pow),\n\t\t\t\tnsnp = sum(pow),\n\t\t\t\tproph2 = sum(h2/sum(h2) * pow),\n\t\t\t\tfracu = sum(pow * u_indicator) / sum(pow)\n\t\t\t)\n\t\treturn(x)\n\t}) %>% bind_rows()\n\tbind_cols(args, o)\n}\nr1 <- simfn2(\n\tnsnpx = 2000,\n\tnsnpu = 2000, \n\tbux = 0.1, \n\tbuy = 0.1, \n\tnid = seq(10000, 10000000, by=10000), \n\th2x = 0.4,\n\th2u = 0.4, \n\tSx = 1,\n\tSu = 1)\n```\n:::\n\n\nSo as sample size increases this is the expected bias in the MR estimate\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(r1, aes(x=nid, y=bias)) +\ngeom_point() +\ngeom_hline(yintercept=0.1*0.1) +\nannotate(\"text\", x=0, y=0.1*0.1, label=\"OLS bias\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-4-1.png){width=672}\n:::\n:::\n\n\nWhich is essentially the same the proportion of discovered variants that influence x through u\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(r1, aes(x=nid, y=fracu)) +\ngeom_point()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-5-1.png){width=672}\n:::\n:::\n\n\nThe shape is somewhat different when looking at it from the perspective of number of variants discovered\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(r1, aes(x=nsnp, y=bias)) +\ngeom_point() +\ngeom_hline(yintercept=0.1*0.1) +\nannotate(\"text\", x=0, y=0.1*0.1, label=\"OLS bias\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-6-1.png){width=672}\n:::\n:::\n\n\nAnd also in terms of variance x explained by the discovered SNPs\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(r1, aes(x=proph2, y=bias)) +\ngeom_point() +\ngeom_hline(yintercept=0.1*0.1) +\nannotate(\"text\", x=0, y=0.1*0.1, label=\"OLS bias\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-7-1.png){width=672}\n:::\n:::\n\n\nSo under this model it's not until you explain quite a large fraction of total heritability does the bias become problematic. This is quite unrealistic because the model assumes that SNPs influencing $x$ **not** through a confounder have larger effects. But perhaps more realistic is that all SNPs influence $x$ through a mediator, but some of those mediators are confounders of the $x-y$ relationship and some are not.\n\nSo if the distribution of instrument effects on x are the same whether going through a confounder or not, the bias is no longer strongly related to sample size\n\n\n::: {.cell}\n\n```{.r .cell-code}\nr2 <- simfn2(\n\tnsnpx = 2000,\n\tnsnpu = 2000, \n\tbax = 0.1,\n\tbux = 0.1, \n\tbuy = 0.1, \n\tnid = seq(10000, 10000000, by=10000), \n\th2x = 0.4,\n\th2u = 0.4, \n\tSx = 1,\n\tSu = 1)\nggplot(r2, aes(x=nid, y=bias)) +\ngeom_point() +\ngeom_hline(yintercept=0.1*0.1) +\nannotate(\"text\", x=0, y=0.1*0.1, label=\"OLS bias\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-8-1.png){width=672}\n:::\n:::\n\n\nTry increasing polygenicity of $u$\n\n\n::: {.cell}\n\n```{.r .cell-code}\nr3 <- simfn2(\n\tnsnpx = 2000,\n\tnsnpu = 4000, \n\tbax = 1,\n\tbux = 0.1, \n\tbuy = 0.1, \n\tnid = seq(10000, 10000000, by=10000), \n\th2x = 0.4,\n\th2u = 0.4, \n\tSx = 1,\n\tSu = 1)\nggplot(r3, aes(x=nid, y=bias)) +\ngeom_point() +\ngeom_hline(yintercept=0.1*0.1) +\nannotate(\"text\", x=0, y=0.1*0.1, label=\"OLS bias\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-9-1.png){width=672}\n:::\n:::\n\n\nThe rate at which higher sample size leads MR estimates becomes biased depends on how quickly the GWAS starts to identify instruments acting through $u$. This will increase under the following conditions\n\n- The effects on $u$ are larger than those not through $u$\n- There are many different $u$ variables through which instruments can be detected\n- The heritability of $u$ is higher\n- The polygenicity of $u$ is lower (i.e. effects are more discoverable)\n\n## Ignore the rest\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnsnp <- 5000\nmapx <- tibble(snp=paste0(1:nsnp, \"x\"), af=runif(nsnp, 0.01, 0.99))\nmapu <- tibble(snp=paste0(1:nsnp, \"u\"), af=runif(nsnp, 0.01, 0.99))\nparamsx <- generate_gwas_params(map=mapx, h2=0.4, S=-0.4, Pi=1)\nparamsu <- generate_gwas_params(map=mapu, h2=0.4, S=-0.4, Pi=1)\n\nbux <- 0.1\nbuy <- 0.1\nparamsx <- rbind(paramsx, paramsu %>% mutate(beta=beta * bux))\n\nssx <- generate_gwas_ss(paramsx, 1000000)\nssx$w <- 1/ssx$se^2\nssx$bias <- buy/bux\nssx$bias[grepl(\"x\", ssx$snp)] <- 0\nssx <- ssx %>% arrange(pval)\no <- map(1:nrow(ssx), \\(i){\n\tx <- ssx[1:i,]\n\ttibble(\n\t\tnsnp=i,\n\t\tbias=sum(x$bias*x$w) / sum(x$w)\n\t)\n}) %>% bind_rows()\no\nggplot(o, aes(x=nsnp, y=bias)) +\ngeom_point() +\ngeom_hline(yintercept=bux*buy)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nsimfn <- function(nsnpx, nsnpu, bux, buy, nid, h2x, h2u, Sx, Su, bax=1) {\n\targs <- environment() %>% as.list() %>% as_tibble()\n\tmapx <- tibble(snp=paste0(1:nsnpx, \"x\"), af=runif(nsnpx, 0.01, 0.99))\n\tmapu <- tibble(snp=paste0(1:nsnpu, \"u\"), af=runif(nsnpu, 0.01, 0.99))\n\tparamsx <- generate_gwas_params(map=mapx, h2=h2x, S=Sx, Pi=1)\n\tparamsu <- generate_gwas_params(map=mapu, h2=h2u, S=Su, Pi=1)\n\tparams <- rbind(paramsx %>% mutate(beta=beta*bax), paramsu %>% mutate(beta=beta * bux))\n\tssx <- generate_gwas_ss(params, nid)\n\tssx$beta <- params$beta\n\tssx$w <- 1/ssx$se^2\n\tssx$bias <- buy/bux\n\tssx$bias[grepl(\"x\", ssx$snp)] <- 0\n\tssx <- ssx %>% mutate(h2 = beta^2 * 2 * af * (1-af))\n\tssx <- ssx %>% arrange(pval)\n\to <- map(1:nrow(ssx), \\(i){\n\t\tx <- ssx[1:i,]\n\t\ttibble(\n\t\t\tnsnp=i,\n\t\t\tpropsnp=nsnp/nrow(ssx),\n\t\t\tproph2=sum(x$h2) / sum(ssx$h2),\n\t\t\tbias=sum(x$bias*x$w) / sum(x$w)\n\t\t)\n\t}) %>% bind_rows()\n\tbind_cols(args, o)\n}\no <- simfn(1000, 1000, 0.1, 0.4, 10000000, 0.3, 0.3, 0, 0)\nggplot(o, aes(x=nsnp, y=bias)) +\ngeom_point() +\ngeom_hline(yintercept=o$bux[1]*o$buy[1])\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nparams <- expand.grid(\n\tbux = seq(-1, 1, by=0.2),\n\tbuy = seq(-1, 1, by=0.2),\n\tnsnpx = c(2000),\n\tnsnpu = c(2000, 4000)\n)\n\nres <- map(1:nrow(params), \\(i) {\n\tsimfn(params$nsnpx[i], params$nsnpu[i], params$bux[i], params$buy[i], 1000000, 0.4, 0.4, 0, 0)\n}, .progress=TRUE) %>% bind_rows()\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nres <- res %>% \n\tgroup_by(bux, buy, nsnpx, nsnpu) %>%\n\tmutate(propsnp=nsnp/max(nsnp))\nobsbias <- res %>% group_by(bux, buy) %>%\n\tsummarise(obsbias=bux[1] * buy[1])\np1 <- res %>%\n\tfilter(bux != 0, buy != 0) %>%\n\tggplot(., aes(x=propsnp, y=bias, group=as.factor(nsnpu))) +\n\tgeom_line(aes(colour=as.factor(nsnpu))) +\n\tgeom_hline(data=obsbias, aes(yintercept=obsbias)) +\n\tfacet_grid(bux ~ buy)\n\np1\nggsave(p1, file=\"res.pdf\", width=15, height=15)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nparams <- expand.grid(\n\tbax = c(0.1, 1),\n\tbux = c(0.1, 0.5, 1),\n\tbuy = c(0.1, 0.5, 1),\n\tnsnpx = c(2000),\n\tnsnpu = c(2000, 4000)\n)\n\nres2 <- map(1:nrow(params), \\(i) {\n\tsimfn(params$nsnpx[i], params$nsnpu[i], params$bux[i], params$buy[i], 1000000, 0.4, 0.4, 0, 0, params$bax[i])\n}, .progress=TRUE) %>% bind_rows()\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nobsbias <- res2 %>% group_by(bax, bux, buy) %>%\n\tsummarise(obsbias=bux[1] * buy[1])\np2 <- res2 %>%\n\tfilter(bux != 0, buy != 0) %>%\n\tggplot(., aes(x=proph2, y=bias, group=as.factor(nsnpu))) +\n\tgeom_line(aes(colour=as.factor(nsnpu))) +\n\tgeom_hline(data=obsbias, aes(yintercept=obsbias)) +\n\tfacet_grid(bux ~ buy + bax, labeller = label_both)\n\np2\nggsave(p2, file=\"res2.pdf\", width=15, height=15)\n```\n:::\n\n\n\n\n\nUse power\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsimfn2 <- function(nsnpx, nsnpu, bux, buy, nid, h2x, h2u, Sx, Su, bax=1) {\n\targs <- environment() %>% as.list() %>% as_tibble()\n\tmapx <- tibble(snp=paste0(1:nsnpx, \"x\"), af=runif(nsnpx, 0.01, 0.99))\n\tmapu <- tibble(snp=paste0(1:nsnpu, \"u\"), af=runif(nsnpu, 0.01, 0.99))\n\tparamsx <- generate_gwas_params(map=mapx, h2=h2x, S=Sx, Pi=1)\n\tparamsu <- generate_gwas_params(map=mapu, h2=h2u, S=Su, Pi=1)\n\tparams <- rbind(paramsx %>% mutate(beta=beta*bax), paramsu %>% mutate(beta=beta * bux))\n\to <- map(nid, \\(i){\n\t\tssx <- generate_gwas_ss(params, i)\n\t\tssx$w <- 1/ssx$se^2\n\t\tssx$bias <- buy/bux\n\t\tssx$bias[grepl(\"x\", ssx$snp)] <- 0\n\t\tssx <- ssx %>% mutate(h2 = bhat^2 * 2 * af * (1-af))\n\t\tssx <- ssx %>% arrange(pval)\n\t\tx <- ssx %>%\n\t\t\tmutate(\n\t\t\t\tn=i,\n\t\t\t\tpow = pwr.r.test(n=i, r=sqrt(ssx$h2), sig.level=5e-8)$power,\n\t\t\t) %>%\n\t\t\tsummarise(\n\t\t\t\tbias = sum(bias * w * pow) / sum(w * pow),\n\t\t\t\tnsnp = sum(pow),\n\t\t\t\tproph2 = sum(h2/sum(h2) * pow),\n\t\t\t)\n\t\treturn(x)\n\t}) %>% bind_rows()\n\tbind_cols(args, o)\n}\n\nparams <- expand.grid(\n\tbax = c(0.1, 1),\n\tbux = c(0.1, 0.5, 1),\n\tbuy = c(0.1, 0.5, 1),\n\tnsnpx = c(2000),\n\tnsnpu = c(2000, 4000)\n)\n\nres3 <- map(1:nrow(params), \\(i) {\n\tsimfn2(params$nsnpx[i], params$nsnpu[i], params$bux[i], params$buy[i], seq(10000,10000000,by=10000), 0.4, 0.4, 0, 0, params$bax[i])\n}, .progress=TRUE) %>% bind_rows()\n\nobsbias <- res3 %>% group_by(bax, bux, buy) %>%\n\tsummarise(obsbias=bux[1] * buy[1])\np3 <- res3 %>%\n\tfilter(bux != 0, buy != 0, nid < 1000000, bax==0.1, nsnp >= 1) %>%\n\tggplot(., aes(x=nid, y=bias, group=as.factor(nsnpu))) +\n\tgeom_line(aes(colour=as.factor(nsnpu))) +\n\tgeom_hline(data=obsbias, aes(yintercept=obsbias)) +\n\tfacet_grid(bux ~ buy, labeller = label_both)\n\nggsave(p3, file=\"res3.pdf\", width=15, height=15)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nu <- rnorm(1000000)\nx <- scale(rnorm(1000000, sd=0.9) + u * 0.1)\ny <- scale(rnorm(1000000, sd=0.9) + u * 0.1)\n\ncor(u,x)\ncor(u,y)\ncor(y,x)\n```\n:::\n\n\n\n\n---\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsessionInfo()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nR version 4.2.3 Patched (2023-03-15 r84020)\nPlatform: aarch64-apple-darwin20 (64-bit)\nRunning under: macOS Monterey 12.6.2\n\nMatrix products: default\nBLAS:   /Library/Frameworks/R.framework/Versions/4.2-arm64/Resources/lib/libRblas.0.dylib\nLAPACK: /Library/Frameworks/R.framework/Versions/4.2-arm64/Resources/lib/libRlapack.dylib\n\nlocale:\n[1] en_US.UTF-8/en_US.UTF-8/en_US.UTF-8/C/en_US.UTF-8/en_US.UTF-8\n\nattached base packages:\n[1] stats     graphics  grDevices utils     datasets  methods   base     \n\nother attached packages:\n[1] pwr_1.3-0         purrr_1.0.1       TwoSampleMR_0.5.6 simulateGP_0.1.2 \n[5] ggplot2_3.4.0     dplyr_1.0.10     \n\nloaded via a namespace (and not attached):\n [1] Rcpp_1.0.9        plyr_1.8.7        pillar_1.8.1      compiler_4.2.3   \n [5] tools_4.2.3       digest_0.6.31     jsonlite_1.8.4    evaluate_0.19    \n [9] lifecycle_1.0.3   tibble_3.1.8      gtable_0.3.1      pkgconfig_2.0.3  \n[13] rlang_1.0.6       DBI_1.1.3         cli_3.5.0         yaml_2.3.6       \n[17] xfun_0.36         fastmap_1.1.0     withr_2.5.0       stringr_1.5.0    \n[21] knitr_1.41        generics_0.1.3    vctrs_0.5.1       htmlwidgets_1.5.4\n[25] grid_4.2.3        tidyselect_1.2.0  glue_1.6.2        R6_2.5.1         \n[29] fansi_1.0.3       rmarkdown_2.16    farver_2.1.1      magrittr_2.0.3   \n[33] scales_1.2.1      htmltools_0.5.4   assertthat_0.2.1  colorspace_2.0-3 \n[37] labeling_0.4.2    utf8_1.2.2        stringi_1.7.8     munsell_0.5.0    \n```\n:::\n:::\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}