{
  "hash": "141e0481a1e11f401ba896553f4bd067",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Polygenic confounding of rare variants\"\nauthor: Gibran Hemani\ndate: \"2024-06-25\"\ncategories: []\nexecute:\n    eval: false\n---\n\n\n## Background\n\nGenerate families with polygenic effects plus null rare variants. Allow for assortative mating. See if there is confounding of rare variants by polygenic effects.\n\n\n## Simulations\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(dplyr)\nlibrary(MASS)\n\ngenerate_assortment <- function(m, f, rho) {\n    stopifnot(length(m) == length(f))\n    require(MASS)\n    mvdat <- mvrnorm(n = length(m), mu=c(0,0), Sigma=matrix(c(1,rho,rho,1), 2,2))\n    rm <- rank(mvdat[ , 1], ties.method = \"first\")\n    rf <- rank(mvdat[ , 2], ties.method = \"first\")\n    m_order <- order(m)\n    f_order <- order(f)\n    return(tibble(m = m_order[rm], f=f_order[rf]))\n}\n\n\nmake_families <- function(betas, nfam, h2, rho) {\n    npoly <- length(betas)\n    g_mother1 <- sapply(1:npoly, \\(i) rbinom(nfam, 1, 0.5))\n    g_mother2 <- sapply(1:npoly, \\(i) rbinom(nfam, 1, 0.5))\n    g_father1 <- sapply(1:npoly, \\(i) rbinom(nfam, 1, 0.5))\n    g_father2 <- sapply(1:npoly, \\(i) rbinom(nfam, 1, 0.5))\n    g_mother1 <- cbind(diag(nfam), g_mother1)\n    g_mother2 <- cbind(matrix(0, nfam, nfam), g_mother2)\n    g_father1 <- cbind(diag(nfam), g_father1)\n    g_father2 <- cbind(matrix(0, nfam, nfam), g_father2)\n\n    prs_mother <- (g_mother1[,(nfam+1):ncol(g_mother1)] + g_mother2[,(nfam+1):ncol(g_mother2)]) %*% betas\n    prs_father <- (g_father1[,(nfam+1):ncol(g_father1)] + g_father2[,(nfam+1):ncol(g_father2)]) %*% betas\n    y_mother <- scale(prs_mother) + rnorm(nfam, 0, sqrt(1 - h2))\n    y_father <- scale(prs_father) + rnorm(nfam, 0, sqrt(1 - h2))\n\n    m <- generate_assortment(y_mother, y_father, rho)\n    g_mother1 <- g_mother1[m$m,]\n    g_mother2 <- g_mother2[m$m,]\n    g_father1 <- g_father1[m$f,]\n    g_father2 <- g_father2[m$f,]\n    y_mother <- y_mother[m$m]\n    y_father <- y_father[m$f]\n    prs_mother <- prs_mother[m$m]\n    prs_father <- prs_father[m$f]\n    return(list(g_mother1 = g_mother1, g_mother2 = g_mother2, g_father1 = g_father1, g_father2 = g_father2, x = tibble(y_mother, y_father, prs_mother, prs_father)))\n}\n\nbetas <- rnorm(100)\ndat <- make_families(betas = betas, nfam = 100, nchild = 100, h2 = 0.8, rho = 0.4, ngen = 100)\n\nstr(dat)\ncor(dat$x$y_mother, dat$x$y_father)\ncor(dat$x$y_mother, dat$x$prs_mother)^2\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ncreate_child <- function(dat, betas, h2, rho) {\n    nfam <- nrow(dat$x)\n    nsnp <- ncol(dat$g_mother1)\n    sib1_m <- matrix(0, nfam, nsnp)\n    sib1_f <- matrix(0, nfam, nsnp)\n    sib2_m <- matrix(0, nfam, nsnp)\n    sib2_f <- matrix(0, nfam, nsnp)\n    for(i in 1:nsnp) {\n        ind <- sample(c(TRUE, FALSE), nfam, replace=TRUE)\n        sib1_m[ind, i] <- dat$g_mother1[ind, i]\n        sib1_m[!ind, i] <- dat$g_mother2[!ind, i]\n        ind <- sample(c(TRUE, FALSE), nfam, replace=TRUE)\n        sib1_f[ind, i] <- dat$g_father1[ind, i]\n        sib1_f[!ind, i] <- dat$g_father2[!ind, i]\n        ind <- sample(c(TRUE, FALSE), nfam, replace=TRUE)\n        sib2_m[ind, i] <- dat$g_mother1[ind, i]\n        sib2_m[!ind, i] <- dat$g_mother2[!ind, i]\n        ind <- sample(c(TRUE, FALSE), nfam, replace=TRUE)\n        sib2_f[ind, i] <- dat$g_father1[ind, i]\n        sib2_f[!ind, i] <- dat$g_father2[!ind, i]\n    }\n\n    prs_sib1 <- (sib1_m[,(nfam+1):nsnp] + sib1_f[,(nfam+1):nsnp]) %*% betas\n    prs_sib2 <- (sib2_m[,(nfam+1):nsnp] + sib2_f[,(nfam+1):nsnp]) %*% betas\n    y_sib1 <- scale(prs_sib1) + rnorm(nfam, 0, sqrt(1 - h2))\n    y_sib2 <- scale(prs_sib2) + rnorm(nfam, 0, sqrt(1 - h2))\n\n    # This doesn't exclude inbreeding\n    m <- generate_assortment(y_sib1, y_sib2, rho)\n    sib1_m <- sib1_m[m$m,]\n    sib1_f <- sib1_f[m$m,]\n    sib2_m <- sib2_m[m$f,]\n    sib2_f <- sib2_f[m$f,]\n    y_sib1 <- y_sib1[m$m]\n    y_sib2 <- y_sib2[m$f]\n    prs_sib1 <- prs_sib1[m$m]\n    prs_sib2 <- prs_sib2[m$f]\n    return(list(g_mother1 = sib1_m, g_mother2 = sib1_f, g_father1 = sib2_m, g_father2 = sib2_f, x = tibble(y_mother=y_sib1, y_father=y_sib2, prs_mother=prs_sib1, prs_father=prs_sib2)))\n}\n\ndat2 <- create_child(dat, betas, h2 = 0.8, rho = 0.4)\nstr(dat2)\ncor(dat2$x$y_mother, dat2$x$y_father)\ncor(dat2$x$prs_mother, dat2$x$prs_father)\ncor(dat2$x$y_mother, dat2$x$prs_mother)^2\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nbetas <- rnorm(100)\ndat <- make_families(betas = betas, nfam = 100, h2 = 0.8, rho = 0.4)\nfor(i in 1:10) {\n    dat <- create_child(dat, betas, h2 = 0.8, rho = 0.4)\n}\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ncollapse_dat <- function(dat) {\n    g_mother <- dat$g_mother1 + dat$g_mother2\n    g_father <- dat$g_father1 + dat$g_father2\n    g <- rbind(g_mother, g_father)\n    x <- tibble(y = c(dat$x$y_mother, dat$x$y_father), prs = c(dat$x$prs_mother, dat$x$prs_father))\n    return(list(g = g, x = x))\n}\n\ndat2 <- collapse_dat(dat)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ncollapse_dat2 <- function(l) {\n    g <- do.call(rbind, lapply(l, \\(x) x$g))\n    x <- do.call(rbind, lapply(1:length(l), \\(i) l[[i]]$x %>% mutate(gen=i)))\n    return(list(g = g, x = x))\n}\n\ntemp <- collapse_dat2(list(collapse_dat(dat), collapse_dat(create_child(dat, betas, h2 = 0.8, rho = 0.4))))\nstr(temp)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nfastAssoc <- function(y, x) {\n\tindex <- is.finite(y) & is.finite(x)\n\tn <- sum(index)\n\ty <- y[index]\n\tx <- x[index]\n\tvx <- var(x)\n\tbhat <- cov(y, x) / vx\n\tahat <- mean(y) - bhat * mean(x)\n\t# fitted <- ahat + x * bhat\n\t# residuals <- y - fitted\n\t# SSR <- sum((residuals - mean(residuals))^2)\n\t# SSF <- sum((fitted - mean(fitted))^2)\n\n\trsq <- (bhat * vx)^2 / (vx * var(y))\n\tfval <- rsq * (n-2) / (1-rsq)\n\ttval <- sqrt(fval)\n    af <- sum(x) / n / 2\n\tse <- abs(bhat / tval)\n\n\t# Fval <- (SSF) / (SSR/(n-2))\n\t# pval <- pf(Fval, 1, n-2, lowe=F)\n\tp <- pf(fval, 1, n-2, lowe=F)\n\treturn(list(\n\t\tahat=ahat, bhat=bhat, se=se, fval=fval, pval=p, af = af\n\t))\n}\n\ngwas <- function(y, g) {\n\tout <- matrix(0, ncol(g), 6)\n\tfor(i in 1:ncol(g))\n\t{\n\t\to <- fastAssoc(y, g[,i])\n\t\tout[i, ] <- unlist(o)\n\t}\n\tout <- as.data.frame(out)\n\tnames(out) <- names(o)\n\treturn(out)\n}\n\ngwas(dat2$x$prs, dat2$g)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ngenotype_means <- function(g, x) {\n    lapply(1:ncol(g), \\(i) {\n        tibble(g = g[,i], x = x) %>% group_by(g) %>% summarise(snp=i, mean = mean(x), sd = sd(x), n = n())\n    }) %>% bind_rows()\n}\n\nqqplot <- function(pvector) {\n    pvector <- pvector[!is.na(pvector) & !is.nan(pvector) & !is.null(pvector) & is.finite(pvector) & pvector<1 & pvector>0]\n    o <- -log10(sort(pvector, decreasing=FALSE))\n    e <- -log10(ppoints(length(pvector)))\n    cs <- qchisq(1-pvector, 1)\n    lambda <- median(cs, na.rm=TRUE) / qchisq(0.5, 1)\n    plot(e, o, xlab = \"Expected\", ylab = \"Observed\")\n    abline(0, 1)\n    return(lambda)\n}\n\ngenotype_means(dat2$g, dat2$x$prs)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nwhole_sim <- function(betas, nfam, h2, rho, ngen) {\n    dat <- make_families(betas = betas, nfam = nfam, h2 = h2, rho = rho)\n    l <- list()\n    l2 <- list()\n    dat2 <- collapse_dat(dat)\n    l[[1]] <- gwas(dat2$x$prs, dat2$g) %>% mutate(gen = 1)\n    l2[[1]] <- l[[1]]\n    for(i in 1:ngen) {\n        message(i)\n        dat <- create_child(dat, betas, h2 = h2, rho = rho)\n        print(cor(dat$x$y_mother, dat$x$y_father))\n        dat3 <- collapse_dat(dat)\n        dat2 <- collapse_dat2(list(dat2, dat3))\n        l[[i+1]] <- gwas(dat2$x$prs, dat2$g) %>% mutate(gen = i+1)\n        l2[[i+1]] <- gwas(dat3$x$prs, dat3$g) %>% mutate(gen = i+1)\n    }\n    res <- bind_rows(l)\n    res2 <- bind_rows(l2)\n    m <- genotype_means(dat2$g, dat2$x$prs)\n    return(list(res, res2, m))\n}\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nout <- whole_sim(betas = rnorm(100), nfam = 1000, h2 = 0.8, rho = 0.4, ngen = 3)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nqqplot(-log10(out[[2]]$pval[1:1000]))\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nout2 <- whole_sim(betas = rnorm(100), nfam = 10000, h2 = 0, rho = 0, ngen = 3)\nqqplot(-log10(out2[[2]]$pval[10001:11000]))\nqqplot(-log10(out2[[2]]$pval[1:10000]))\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nout <- whole_sim(betas = rnorm(100), nfam = 10000, h2 = 0.8, rho = 0.4, ngen = 3)\nqqplot(-log10(out[[2]]$pval[10001:11000]))\nqqplot(-log10(out[[2]]$pval[1:10000]))\n```\n:::\n\n\n\n\n- Find families\n- Mean PRS per family\n- For families with large PRS, do they have rare variants?\n- Do those rare variants associate with PRS?\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmake_grm <- function(g) {\n    f <- colMeans(g) / 2\n    g <- scale(g)\n    m <- matrix(0, nrow(g), nrow(g))\n    npol <- sum(f > 0)\n    for(i in 1:nrow(g)) {\n        for(j in 1:i) {\n            x <- sum(g[i,] * g[j,], na.rm=TRUE) / npol\n            # print(x)\n            m[i,j] <- x\n            m[j,i] <- m[i,j]\n        }\n    }\n    # hist(m[lower.tri(m)], breaks=100)\n    return(m)\n}\n\ngreedy_remove_relateds <- function(m) {\n    n <- nrow(m)\n    keep <- rep(TRUE, n)\n\n    b <- tibble(\n        id=1:n,\n        rel=sapply(1:n, \\(i) sum(m[i,] > 0.2) - 1)\n    ) %>% arrange(desc(rel)) %>%\n    filter(rel > 0)\n\n    diag(m) <- 0\n    while(nrow(b) > 0) {\n        message(nrow(b))\n        keep[b$id[1]] <- FALSE\n        m[b$id[1],] <- 0\n        m[,b$id[1]] <- 0\n        b <- tibble(\n            id=1:n,\n            rel=sapply(1:n, \\(i) sum(m[i,] > 0.2) - 1)\n        ) %>% arrange(desc(rel)) %>%\n        filter(rel > 0)\n        print(head(b))\n    }\n    return(keep)\n}\n\nbetas <- rnorm(100)\ndat <- make_families(betas = betas, nfam = 100, h2 = 0.8, rho = 0.4)\ndat2 <- create_child(dat, betas, h2 = 0.8, rho = 0.4)\ndat3 <- create_child(dat2, betas, h2 = 0.8, rho = 0.4)\ndat4 <- create_child(dat3, betas, h2 = 0.8, rho = 0.4)\ndat5 <- create_child(dat4, betas, h2 = 0.8, rho = 0.4)\ncdat <- collapse_dat2(lapply(list(dat, dat2, dat3, dat4, dat5), collapse_dat))\nstr(cdat)\n\nstr(dat2)\ng <- cdat$g\ng <- collapse_dat(dat)$g\ng <- collapse_dat(dat2)$g\nm <- make_grm(g)\n\nk <- greedy_remove_relateds(m)\nm <- m[k, k]\ndim(m)\n\ndim(m)\ng[1:10,1:10]\napply(g, 2, mean)\n\nsum(g[1,] * g[2,]) / length(g[1,])\n\ngr <- graph_\n\nlibrary(ggplot2)\n\nhist(m[lower.tri(m)], breaks=100)\n\nfind_families <- function(cdat) {\n    gens <- unique(cdat$x$gen)\n    lapply(gens, function(i) {\n        m <- make_grm(cdat$g[cdat$x$gen == i,])\n        diag(m) <- 0\n        m[m < 0.2] <- 0\n        m[m >= 0.2] <- 1\n        gr <- graph_from_adjacency_matrix(m)\n        rw <- cluster_walktrap(gr)\n        rw$membership\n        x <- cdat$x[cdat$x$gen == i,] %>% mutate(fid = rw$membership)\n        xs <- x %>% group_by(fid) %>% summarise(mean_prs = mean(prs), n = n(), se_prs = sd(prs) / sqrt(n())) %>% arrange(desc(mean_prs)) %>% filter(n > 1) %>% mutate(fam=1:n(), gen=i)\n        return(xs)\n    }) %>% bind_rows()\n}\n\n\n\n\n\n\n\ncdat <- collapse_dat2(lapply(list(dat, dat2), collapse_dat))\nfind_families(cdat)\ncdat <- collapse_dat2(lapply(list(dat, dat2, dat3, dat4, dat5), collapse_dat))\nf <- find_families(cdat)\ntable(f$gen)\nggplot(f, aes(x=mean_prs, y=fam)) +\ngeom_point() + \ngeom_errorbarh(aes(xmin=mean_prs - 1.96 * se_prs, xmax=mean_prs + 1.96 * se_prs), height=0) +\nfacet_grid(. ~ gen)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nfam_sim <- function(ngen, nfam, npoly, h2, rho) {\n    betas <- rnorm(npoly)\n    l <- list()\n    l[[1]] <- make_families(betas = betas, nfam = nfam, h2 = h2, rho = rho)\n    for(i in 2:ngen) {\n        l[[i]] <- create_child(l[[i-1]], betas, h2 = h2, rho = rho)\n    }\n    cdat <- collapse_dat2(lapply(l, collapse_dat))\n    xs <- find_families(cdat) %>% mutate(npoly=npoly, nfam=nfam, h2=h2, rho=rho)\n    return(xs)\n}\n\na <- fam_sim(11, 500, 100, 0.8, 0)\na\n\na %>% group_by(gen) %>%\n    filter(row_number()==1 | row_number()==n()) %>%\n    ggplot(., aes(y=mean_prs, x=gen)) +\n    geom_point() + \n    geom_errorbar(aes(ymin=mean_prs - 1.96 * se_prs, ymax=mean_prs + 1.96 * se_prs), width=0)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nparam <- expand.grid(\n    ngen = 10,\n    nfam = 250,\n    npoly = 100,\n    h2 = 0.8,\n    rho = c(0, 0.2, 0.4, 0.6, 0.8),\n    sims = 1:10\n)\n\no <- lapply(1:nrow(param), \\(i) {\n    message(i)\n    fam_sim(param$ngen[i], param$nfam[i], param$npoly[i], param$h2[i], param$rho[i])\n}) %>% bind_rows()\n```\n:::\n::: {.cell}\n\n```{.r .cell-code}\nbetas <- rnorm(100)\ndat <- make_families(betas = betas, nfam = 100, h2 = 0.8, rho = 0.4)\ndat2 <- create_child(dat, betas, h2 = 0.8, rho = 0.4)\ncdat <- collapse_dat2(list(collapse_dat(dat), collapse_dat(dat2)))\nstr(cdat)\n\ndat$x %>% mutate(s=prs_mother+prs_father) %>% mutate(fid=1:n()) %>% arrange(desc(s))\n\nhist(dat$x$prs_mother, breaks=100)\n```\n:::\n\n\n\n\n\n---\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsessionInfo()\n```\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}