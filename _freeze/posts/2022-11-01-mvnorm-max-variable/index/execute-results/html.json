{
  "hash": "dc31f365cdd184e0bcac59f625e736ff",
  "result": {
    "markdown": "---\ntitle: \"Probability of a random variable being larger than all other random variables in a multivariate normal vector\"\nauthor: \"Gibran Hemani\"\ndate: \"2022-11-01\"\ncategories: [statistics]\n---\n\n\nI have 1k SNPs in a region. I know the causal variant and the LD matrix. The effect size at each SNP will be related to the allele frequency and the LD at all other variants. The SE across the SNPs will be correlated in relation to the LD. I can generate the expected effect size and the variance covariance matrix of the effects. Once I have that, I can generate beta values from a multivariate normal distribution, and determine how often each of the SNPs is the top SNP.\n\nIs there a faster way to do this by getting the probability from a multivariate normal distribution?\n\nRelated to this question: https://stats.stackexchange.com/a/4181\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(MCMCpack)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nLoading required package: coda\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nLoading required package: MASS\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\n##\n## Markov Chain Monte Carlo Package (MCMCpack)\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\n## Copyright (C) 2003-2022 Andrew D. Martin, Kevin M. Quinn, and Jong Hee Park\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\n##\n## Support provided by the U.S. National Science Foundation\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\n## (Grants SES-0350646 and SES-0350613)\n##\n```\n:::\n\n```{.r .cell-code}\nlibrary(dplyr)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n\nAttaching package: 'dplyr'\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nThe following object is masked from 'package:MASS':\n\n    select\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nThe following objects are masked from 'package:stats':\n\n    filter, lag\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nThe following objects are masked from 'package:base':\n\n    intersect, setdiff, setequal, union\n```\n:::\n\n```{.r .cell-code}\nlibrary(simulateGP)\nlibrary(MASS)\nlibrary(mvtnorm)\n```\n:::\n\n\nEmpirical simulation for probabilities, case of 3 variables\n\n\n::: {.cell}\n\n```{.r .cell-code}\nn <- 3\nmu <- rnorm(n)\nS <- rwish(n, diag(n))\nemp <- mvrnorm(1000, mu, S)\nres <- apply(emp, 1, function(x) which.max(x)) %>% table() %>% prop.table()\nres\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n.\n    1     2     3 \n0.666 0.146 0.188 \n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nA <- matrix(c(1,-1,0, 1,0,-1), nrow = 2, byrow = TRUE)\nnewMu <- as.vector(A %*% mu)\nnewS <- A %*% S %*% t(A)\npmvnorm(lower=c(0,0), mean = newMu, sigma = newS)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0.6660382\nattr(,\"error\")\n[1] 1e-15\nattr(,\"msg\")\n[1] \"Normal Completion\"\n```\n:::\n\n```{.r .cell-code}\nA <- matrix(c(1,-1,0, 1,0,-1), nrow = 2, byrow = TRUE)\nA <- A[,c(2,1,3)]\nnewMu <- as.vector(A %*% mu)\nnewS <- A %*% S %*% t(A)\npmvnorm(lower=c(0,0), mean = newMu, sigma = newS)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0.1487365\nattr(,\"error\")\n[1] 1e-15\nattr(,\"msg\")\n[1] \"Normal Completion\"\n```\n:::\n\n```{.r .cell-code}\nA <- matrix(c(1,-1,0, 1,0,-1), nrow = 2, byrow = TRUE)\nA <- A[,c(2,3,1)]\nnewMu <- as.vector(A %*% mu)\nnewS <- A %*% S %*% t(A)\npmvnorm(lower=c(0,0), mean = newMu, sigma = newS)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0.1852253\nattr(,\"error\")\n[1] 1e-15\nattr(,\"msg\")\n[1] \"Normal Completion\"\n```\n:::\n:::\n\n\nIncrease to arbitrary variables\n\n\nUse wishart distribution to generate random vcov matrix\n\n\n::: {.cell}\n\n```{.r .cell-code}\nn <- 100\nmu <- rnorm(n)\nS <- rwish(n, diag(n))\n```\n:::\n\n\nEmpirically generate correlated variables and count how often each one is the largest\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsamp <- mvrnorm(10000, mu, S)\nres <- apply(samp, 1, function(x) which.max(x)) %>% table() %>% prop.table()\nres\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n.\n     1      2      3      4      5      6      7      8      9     10     11 \n0.0232 0.0085 0.0211 0.0072 0.0152 0.0118 0.0038 0.0161 0.0058 0.0094 0.0080 \n    12     13     14     15     16     17     18     19     20     21     22 \n0.0083 0.0152 0.0250 0.0103 0.0131 0.0115 0.0112 0.0093 0.0105 0.0084 0.0066 \n    23     24     25     26     27     28     29     30     31     32     33 \n0.0055 0.0088 0.0150 0.0098 0.0182 0.0171 0.0065 0.0090 0.0074 0.0134 0.0057 \n    34     35     36     37     38     39     40     41     42     43     44 \n0.0125 0.0084 0.0129 0.0088 0.0110 0.0222 0.0154 0.0079 0.0046 0.0111 0.0045 \n    45     46     47     48     49     50     51     52     53     54     55 \n0.0045 0.0071 0.0034 0.0045 0.0133 0.0053 0.0096 0.0013 0.0078 0.0138 0.0053 \n    56     57     58     59     60     61     62     63     64     65     66 \n0.0138 0.0039 0.0025 0.0101 0.0100 0.0059 0.0050 0.0206 0.0043 0.0157 0.0068 \n    67     68     69     70     71     72     73     74     75     76     77 \n0.0068 0.0119 0.0097 0.0117 0.0030 0.0162 0.0082 0.0040 0.0077 0.0156 0.0037 \n    78     79     80     81     82     83     84     85     86     87     88 \n0.0135 0.0082 0.0168 0.0033 0.0095 0.0072 0.0062 0.0124 0.0062 0.0156 0.0088 \n    89     90     91     92     93     94     95     96     97     98     99 \n0.0038 0.0141 0.0086 0.0089 0.0184 0.0117 0.0069 0.0180 0.0098 0.0110 0.0058 \n   100 \n0.0071 \n```\n:::\n:::\n\n\nUse probability density function instead, evaluating for each variable the probability that it's larger than all the other variables\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Create design matrix\nswap_1 <- function(n, i)\n{\n  ind <- 1:n\n  if(i == 1) return(ind)\n  ind[i] <- 1\n  ind[1:(i-1)] <- 2:i\n  return(ind)\n}\n#sapply(1:7, function(i) swap_1(7, i))\nA <- cbind(\n  rep(1, n-1),\n  diag(rep(-1, n-1))\n) %>% as.matrix()\n\nemp <- sapply(1:n, function(i)\n{\n  A <- A[,swap_1(n,i)]\n  newMu <- as.vector(A %*% mu)\n  newS <- A %*% S %*% t(A)\n  pmvnorm(lower=rep(0,n-1), mean = newMu, sigma = newS)\n})\nplot(emp ~ as.numeric(res))\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-6-1.png){width=672}\n:::\n:::\n\n\n\nTheoretical result works fine but is slower than empirical sampling.\n\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}