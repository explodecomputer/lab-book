{
  "hash": "a6556ba73e09437b2f1a9ddbd0547d2e",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Meta analysis including small samples\"\nauthor: Gibran Hemani\ndate: \"2024-09-28\"\ncategories: []\n---\n\n\n## Background\n\nDoes meta analysis with very small samples lead to bias?\n\n- Simulate a regression\n- Split the data into different size groups and meta analyse the groups\n- Compare the meta-analysis results to the full analysis\n- Does smaller group size lead to bias?\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(dplyr)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\n\nAttaching package: 'dplyr'\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nThe following objects are masked from 'package:stats':\n\n    filter, lag\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nThe following objects are masked from 'package:base':\n\n    intersect, setdiff, setequal, union\n```\n\n\n:::\n\n```{.r .cell-code}\nlibrary(ggplot2)\nlibrary(tidyr)\nivw <- function(betas, ses) {\n  weights <- 1 / ses^2\n  beta <- sum(weights * betas) / sum(weights)\n  se <- 1 / sqrt(sum(weights))\n  return(c(beta, se))\n}\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nfast_assoc <- function(y, x) {\n\tindex <- is.finite(y) & is.finite(x)\n\tn <- sum(index)\n\ty <- y[index]\n\tx <- x[index]\n\tvx <- var(x)\n\tbhat <- stats::cov(y, x) / vx\n\tahat <- mean(y) - bhat * mean(x)\n\t# fitted <- ahat + x * bhat\n\t# residuals <- y - fitted\n\t# SSR <- sum((residuals - mean(residuals))^2)\n\t# SSF <- sum((fitted - mean(fitted))^2)\n\n\trsq <- (bhat * vx)^2 / (vx * var(y))\n\tfval <- rsq * (n-2) / (1-rsq)\n\ttval <- sqrt(fval)\n\tse <- abs(bhat / tval)\n\n\t# Fval <- (SSF) / (SSR/(n-2))\n\t# pval <- pf(Fval, 1, n-2, lowe=F)\n\t# p <- stats::pf(fval, 1, n-2, lower.tail=FALSE)\n\treturn(list(\n\t\tahat=ahat, bhat=bhat, se=se, fval=fval, n=n\n\t))\n}\n\nsim <- function(n, nbreak, beta, af) {\n    g <- rbinom(n, 2, af)\n    y <- g * beta + rnorm(n)\n    full <- summary(lm(y ~ g))\n    breaks <- cut(1:n, breaks=nbreak)\n    r <- lapply(levels(breaks), \\(l) {\n        y <- y[breaks == l]\n        g <- g[breaks == l]\n        if(length(unique(g)) == 1) return(NULL)\n        a <- fast_assoc(y, g)\n        tibble(\n            beta = a$bhat,\n            se = a$se\n        )\n    }) %>% bind_rows()\n    meta <- ivw(r$beta, r$se)\n    tibble(\n        n=n, nbreak=nbreak, beta=beta, af=af,\n        bhat=c(full$coefficients[2, 1], meta[1]),\n        se=c(full$coefficients[2, 2], meta[2]),\n        what=c(\"full\", \"meta\")\n    )\n}\nsim(10000, 1000, 0.2, 0.5)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 2 × 7\n      n nbreak  beta    af  bhat     se what \n  <dbl>  <dbl> <dbl> <dbl> <dbl>  <dbl> <chr>\n1 10000   1000   0.2   0.5 0.198 0.0143 full \n2 10000   1000   0.2   0.5 0.205 0.0131 meta \n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nparam <- expand.grid(\n    n = 10000,\n    nbreak = c(10, 100, 1000),\n    beta = c(0, 0.2),\n    af = c(0.1, 0.5),\n    nsim = 1:30\n)\ndim(param)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 360   5\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nres <- lapply(1:nrow(param), \\(i) {\n    sim(param$n[i], param$nbreak[i], param$beta[i], param$af[i]) %>% mutate(sim=param$nsim[i])\n}) %>% bind_rows()\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(res, aes(x=as.factor(nbreak), y=bhat, color=what)) +\n    geom_boxplot() +\n    facet_grid(beta ~ af, labeller=label_both)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-5-1.png){width=672}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nresw <- pivot_wider(res, names_from=what, values_from=c(bhat, se))\nggplot(resw, aes(x=bhat_full, y=bhat_meta)) +\ngeom_point() +\nfacet_wrap(~beta + af + nbreak, scale=\"free\", labeller=label_both) +\ngeom_abline(slope=1, intercept=0)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-6-1.png){width=672}\n:::\n:::\n\n\n\n## Try again with just continuous data\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsim2 <- function(n, nbreak, beta) {\n    g <- rnorm(n)\n    y <- g * beta + rnorm(n)\n    full <- summary(lm(y ~ g))\n    breaks <- cut(1:n, breaks=nbreak)\n    r <- lapply(levels(breaks), \\(l) {\n        y <- y[breaks == l]\n        g <- g[breaks == l]\n        if(length(unique(g)) == 1) return(NULL)\n        a <- fast_assoc(y, g)\n        tibble(\n            beta = a$bhat,\n            se = a$se\n        )\n    }) %>% bind_rows()\n    meta <- ivw(r$beta, r$se)\n    tibble(\n        n=n, nbreak=nbreak, beta=beta,\n        bhat=c(full$coefficients[2, 1], meta[1]),\n        se=c(full$coefficients[2, 2], meta[2]),\n        what=c(\"full\", \"meta\")\n    )\n}\nsim2(10000, 1000, 0.2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 2 × 6\n      n nbreak  beta  bhat      se what \n  <dbl>  <dbl> <dbl> <dbl>   <dbl> <chr>\n1 10000   1000   0.2 0.197 0.00980 full \n2 10000   1000   0.2 0.209 0.00899 meta \n```\n\n\n:::\n\n```{.r .cell-code}\nsim2(10000, 100, 0.2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 2 × 6\n      n nbreak  beta  bhat      se what \n  <dbl>  <dbl> <dbl> <dbl>   <dbl> <chr>\n1 10000    100   0.2 0.170 0.0100  full \n2 10000    100   0.2 0.171 0.00997 meta \n```\n\n\n:::\n\n```{.r .cell-code}\nsim2(10000, 10, 0.2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 2 × 6\n      n nbreak  beta  bhat     se what \n  <dbl>  <dbl> <dbl> <dbl>  <dbl> <chr>\n1 10000     10   0.2 0.194 0.0101 full \n2 10000     10   0.2 0.193 0.0101 meta \n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nparam2 <- expand.grid(\n    n = 10000,\n    nbreak = c(10, 100, 1000),\n    beta = c(0, 0.2),\n    nsim = 1:100\n)\ndim(param2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 600   4\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nres2 <- lapply(1:nrow(param2), \\(i) {\n    sim2(param2$n[i], param2$nbreak[i], param2$beta[i]) %>% mutate(sim=param2$nsim[i])\n}) %>% bind_rows()\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nresw <- pivot_wider(res2, names_from=what, values_from=c(bhat, se))\nggplot(resw, aes(x=bhat_full, y=bhat_meta)) +\ngeom_point() +\nfacet_wrap(~beta + nbreak, scale=\"free\", labeller=label_both) +\ngeom_abline(slope=1, intercept=0) +\ngeom_smooth(method=\"lm\")\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\n`geom_smooth()` using formula = 'y ~ x'\n```\n\n\n:::\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-10-1.png){width=672}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(resw, aes(x=se_full, y=se_meta)) +\ngeom_point() +\nfacet_wrap(~beta + nbreak, scale=\"free\", labeller=label_both) +\ngeom_abline(slope=1, intercept=0) +\ngeom_smooth(method=\"lm\")\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\n`geom_smooth()` using formula = 'y ~ x'\n```\n\n\n:::\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-11-1.png){width=672}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nres2 %>% \n    mutate(pval = pnorm(abs(bhat)/se, low=F)) %>%\n    filter(beta == 0) %>%\n    group_by(nbreak, what) %>%\n    summarise(power = sum(pval < 0.05)/n(), n=n())\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\n`summarise()` has grouped output by 'nbreak'. You can override using the\n`.groups` argument.\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 6 × 4\n# Groups:   nbreak [3]\n  nbreak what  power     n\n   <dbl> <chr> <dbl> <int>\n1     10 full   0.03   100\n2     10 meta   0.03   100\n3    100 full   0.1    100\n4    100 meta   0.11   100\n5   1000 full   0.1    100\n6   1000 meta   0.26   100\n```\n\n\n:::\n:::\n\n\n\n## Summary\n\n- No bias\n- The effects are not identical and become more noisy as the sample size decreases. \n- The standard error is under estimated for the meta analysis as the sample sizes decrease, which leads to slight elevation of type 1 error. \n\n---\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsessionInfo()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nR version 4.4.1 (2024-06-14)\nPlatform: aarch64-apple-darwin20\nRunning under: macOS Sonoma 14.6.1\n\nMatrix products: default\nBLAS:   /Library/Frameworks/R.framework/Versions/4.4-arm64/Resources/lib/libRblas.0.dylib \nLAPACK: /Library/Frameworks/R.framework/Versions/4.4-arm64/Resources/lib/libRlapack.dylib;  LAPACK version 3.12.0\n\nlocale:\n[1] en_US.UTF-8/en_US.UTF-8/en_US.UTF-8/C/en_US.UTF-8/en_US.UTF-8\n\ntime zone: Europe/London\ntzcode source: internal\n\nattached base packages:\n[1] stats     graphics  grDevices utils     datasets  methods   base     \n\nother attached packages:\n[1] tidyr_1.3.1   ggplot2_3.5.1 dplyr_1.1.4  \n\nloaded via a namespace (and not attached):\n [1] Matrix_1.7-0      gtable_0.3.5      jsonlite_1.8.8    compiler_4.4.1   \n [5] tidyselect_1.2.1  splines_4.4.1     scales_1.3.0      yaml_2.3.8       \n [9] fastmap_1.2.0     lattice_0.22-6    R6_2.5.1          labeling_0.4.3   \n[13] generics_0.1.3    knitr_1.47        htmlwidgets_1.6.4 tibble_3.2.1     \n[17] munsell_0.5.1     pillar_1.9.0      rlang_1.1.3       utf8_1.2.4       \n[21] xfun_0.44         cli_3.6.2         withr_3.0.0       magrittr_2.0.3   \n[25] mgcv_1.9-1        digest_0.6.35     grid_4.4.1        lifecycle_1.0.4  \n[29] nlme_3.1-164      vctrs_0.6.5       evaluate_0.23     glue_1.7.0       \n[33] farver_2.1.2      fansi_1.0.6       colorspace_2.1-0  rmarkdown_2.27   \n[37] purrr_1.0.2       tools_4.4.1       pkgconfig_2.0.3   htmltools_0.5.8.1\n```\n\n\n:::\n:::\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}