{
  "hash": "0ac6d512adddd9f37a4f11e0cb73c5ae",
  "result": {
    "markdown": "---\ntitle: \"Confounder instruments via networks\"\nauthor: Gibran Hemani\ndate: \"2023-07-07\"\ncategories: [confounding, mr]\n---\n\n\n## Background\n\nIn a previous [post](../2023-05-13-mr-confounder/index.qmd) looked at the rate of bias as GWAS sample size increases. It was predicated on smaller effects more likely acting via confounders.\n\nWhat is the justification for smaller effects acting via confounders? After all, all effects likely act via mediators. Some of those mediators will confound a X-Y relationship while some will not. Is there any reason to believe that as effects get smaller they're more likely to act via a confounder?\n\nImagine a large DAG representing the genotype-phenotype map. All nodes that have no parents are genetic variants. All other nodes are traits. If you choose any two traits, one as the exposure and one as the outcome, what is the nature of the instruments for the exposure? Hypothesis: the instruments that are mediated by confounders are likely to be more distal from the exposure, compared to those that act via non-confounding mediators.\n\nThese simulations aim to test that.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(dagitty)\nlibrary(dplyr)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n\nAttaching package: 'dplyr'\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nThe following objects are masked from 'package:stats':\n\n    filter, lag\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nThe following objects are masked from 'package:base':\n\n    intersect, setdiff, setequal, union\n```\n:::\n\n```{.r .cell-code}\nlibrary(furrr)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nLoading required package: future\n```\n:::\n\n```{.r .cell-code}\nlibrary(ggplot2)\nlibrary(tictoc)\n\nsimulategraphconf <- function(n, p) {\n\t# Generate graph\n\tg <- dagitty::randomDAG(n, p)\n\n\t# All ancestors\n\tanc <- lapply(names(g), \\(x) ancestors(g, x))\n\tnames(anc) <- names(g)\n\n\t# Identify genetic factors (no ancestors)\n\ttemp <- lapply(anc, length)\n\ttemp <- tibble(node=names(temp), nanc=unlist(temp))\n\n\tgen <- subset(temp, nanc==1)$node\n\tmessage(\"Number of genetic variants: \", length(gen))\n\n\ttraits <- subset(temp, nanc != 1)$node\n\tmessage(\"Number of traits: \", length(traits))\n\t# Find distance of all genetic variants to \n\n\t# Find all trait pairs\n\ttp <- lapply(traits, \\(tr) {\n\t\ttemp <- ancestors(g, tr)\n\t\ttibble(x=temp, y=tr) %>%\n\t\t\tfilter(! x %in% c(gen, tr))\n\t}) %>% bind_rows\n\t# tp <- expand.grid(x=traits, y=traits) %>%\n\t# \tas_tibble() %>%\n\t# \tfilter(x != y)\n\tmessage(\"Number of trait pairs: \", nrow(tp))\n\n\tres <- furrr::future_map(1:min(nrow(tp), 500), \\(i)\n\t{\n\t\tx_ancestors <- ancestors(g, tp$x[i])\n\t\tx_ancestors <- x_ancestors[x_ancestors %in% gen]\n\t\ty_ancestors <- ancestors(g, tp$y[i])\n\t\ty_ancestors <- y_ancestors[y_ancestors %in% gen]\n\n\t\tconf <- c()\n\t\tnonconf <- c()\n\t\tfor(a in y_ancestors)\n\t\t{\n\t\t\tx <- paths(g, a, tp$y[i], dir=T)$paths\n\t\t\tif(any(!grepl(paste0(\" \", tp$x[i], \" \"), x)))\n\t\t\t{\n\t\t\t\tconf <- c(conf, a)\n\t\t\t} else {\n\t\t\t\tnonconf <- c(nonconf, a)\n\t\t\t}\n\t\t}\n\t\tbind_rows(\n\t\t\tlapply(conf, function(co)\n\t\t\t{\n\t\t\t\tpa <- paths(g, co, tp$x[i], directed=TRUE)$paths\n\t\t\t\tif(length(pa) != 0)\n\t\t\t\t{\n\t\t\t\t\ttibble(\n\t\t\t\t\t\tx=tp$x[i],\n\t\t\t\t\t\ty=tp$y[i],\n\t\t\t\t\t\tgen=co,\n\t\t\t\t\t\ttype=\"confounder\",\n\t\t\t\t\t\tw=pa %>%\n\t\t\t\t\t\t\tsapply(., function(x)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tstringr::str_count(x, \"->\") %>%\n\t\t\t\t\t\t\t\tunlist() %>%\n\t\t\t\t\t\t\t\t{0.2^.}\n\t\t\t\t\t\t\t}) %>% sum\n\t\t\t\t\t)\n\t\t\t\t} else {\n\t\t\t\t\tNULL\n\t\t\t\t}\n\t\t\t}) %>% bind_rows(),\n\t\t\tlapply(nonconf, function(co)\n\t\t\t{\n\t\t\t\tpa <- paths(g, co, tp$x[i], directed=TRUE)$paths\n\t\t\t\tif(length(pa) != 0)\n\t\t\t\t{\n\t\t\t\t\ttibble(\n\t\t\t\t\t\tx=tp$x[i],\n\t\t\t\t\t\ty=tp$y[i],\n\t\t\t\t\t\tgen=co,\n\t\t\t\t\t\ttype=\"direct\",\n\t\t\t\t\t\tw=pa %>%\n\t\t\t\t\t\t\tsapply(., function(x)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tstringr::str_count(x, \"->\") %>%\n\t\t\t\t\t\t\t\tunlist() %>%\n\t\t\t\t\t\t\t\t{0.2^.}\n\t\t\t\t\t\t\t}) %>% sum\n\t\t\t\t\t)\n\t\t\t\t} else {\n\t\t\t\t\tNULL\n\t\t\t\t}\n\t\t\t}) %>% bind_rows()\n\t\t)\n\t}) %>% bind_rows()\n\t# res$causal <- paste(res$x, res$y) %in% paste(tpc$x, tpc$y)\n\treturn(res)\n}\n\nset.seed(1234) # note this doesn't work for dagitty - for seed should use pcalg\nplan(multisession, workers=1)\ntic()\nres <- simulategraphconf(50, 0.1)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nNumber of genetic variants: 8\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nNumber of traits: 42\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nNumber of trait pairs: 278\n```\n:::\n\n```{.r .cell-code}\ntoc()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n17.931 sec elapsed\n```\n:::\n\n```{.r .cell-code}\nres %>% group_by(type) %>% summarise(\n\tn=n(),\n\tw=mean(w)\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 2 Ã— 3\n  type           n      w\n  <chr>      <int>  <dbl>\n1 confounder   437 0.0928\n2 direct       108 0.126 \n```\n:::\n:::\n\n\nRun the simulations (note, ran this externally on epifranklin)\n\n\n::: {.cell}\n\n```{.r .cell-code}\nparam <- expand.grid(\n\tn=seq(75, 150, by=25),\n\tp=seq(0.01, 0.1, by=0.01),\n\trep=c(1:10)\n)\n\nres <- lapply(1:nrow(param), \\(i) {\n\tmessage(i)\n\tres <- simulategraphconf(param$n[i], param$p[i])\n\tres %>% group_by(type) %>% summarise(\n\t\tntype=n(),\n\t\tw=mean(w)\n\t) %>% mutate(\n\t\tn=param$n[i],\n\t\tp=param$p[i],\n\t\trep=param$rep[i]\n\t)\n}) %>% bind_rows(res)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nres <- readRDS(\"mrnetworkconf.rds\")\nres %>%\nggplot(., aes(x=p, y=w)) +\ngeom_jitter(aes(colour=type, size=n), alpha=0.4, width=0.001) +\ngeom_smooth(aes(colour=type), se=F) +\nlabs(size=\"Graph size\", x=\"Graph density\", y=\"Mean effect size (arbitrary units)\", colour=\"Mediating traits\")\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n`geom_smooth()` using method = 'loess' and formula = 'y ~ x'\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: Removed 594 rows containing non-finite values (`stat_smooth()`).\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: Removed 594 rows containing missing values (`geom_point()`).\n```\n:::\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-3-1.png){width=672}\n:::\n:::\n\n\nSo the effect sizes for instruments acting via non-confounders tend to be substantially larger than those acting via confounders.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggsave(\"mrnetworkconf.pdf\")\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nSaving 7 x 5 in image\n`geom_smooth()` using method = 'loess' and formula = 'y ~ x'\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: Removed 594 rows containing non-finite values (`stat_smooth()`).\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: Removed 594 rows containing missing values (`geom_point()`).\n```\n:::\n:::\n\n\n## Alternative graph generating method\n\nPhenomic layers. But it's not clear how to generate this realistically. Not implemented in sims yet.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsim_graph <- function(ng, ne, np, nm, nd, nge, nep, npm, nmd) {\n\tlinks <- bind_rows(\n\t\ttibble(\n\t\t\tx=sample(paste0(\"g\", 1:ng), nge, replace=TRUE),\n\t\t\ty=sample(paste0(\"e\", 1:ne), nge, replace=TRUE)\n\t\t),\n\t\ttibble(\n\t\t\tx=sample(paste0(\"e\", 1:ne), nep, replace=TRUE),\n\t\t\ty=sample(paste0(\"p\", 1:np), nep, replace=TRUE)\n\t\t),\n\t\ttibble(\n\t\t\tx=sample(paste0(\"p\", 1:np), npm, replace=TRUE),\n\t\t\ty=sample(paste0(\"m\", 1:nm), npm, replace=TRUE)\n\t\t),\n\t\ttibble(\n\t\t\tx=sample(paste0(\"m\", 1:nm), nmd, replace=TRUE),\n\t\t\ty=sample(paste0(\"d\", 1:nd), nmd, replace=TRUE)\n\t\t)\n\t) %>% mutate(\n\t\trel=paste0(x, \" -> \", y)\n\t)\n\tg <- dagitty(paste(\"dag{\",\n\t\tpaste(links$rel, collapse=\"\\n\"),\n\t\"}\"))\n\treturn(g)\n}\n\ng <- sim_graph(400, 200, 300, 400, 20, 600, 200, 200, 300)\nplot(g)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nPlot coordinates for graph not supplied! Generating coordinates, see ?coordinates for how to set your own.\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning in arrows(ax1[directed], -ay1[directed], ax2[directed], -ay2[directed],\n: zero-length arrow is of indeterminate angle and so skipped\n\nWarning in arrows(ax1[directed], -ay1[directed], ax2[directed], -ay2[directed],\n: zero-length arrow is of indeterminate angle and so skipped\n```\n:::\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-5-1.png){width=672}\n:::\n\n```{.r .cell-code}\nancestors(g, \"d1\") %>% {grep(\"g\", ., value=TRUE)}\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"g79\"  \"g341\" \"g262\" \"g199\" \"g186\" \"g93\"  \"g170\"\n```\n:::\n\n```{.r .cell-code}\npaths(g, \"g79\", \"d1\", dir=T)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$paths\n[1] \"g79 -> e43 -> p236 -> m215 -> d1\"\n\n$open\n[1] TRUE\n```\n:::\n\n```{.r .cell-code}\npaths(g, \"g79\", \"d3\", dir=T)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$paths\nlist()\n\n$open\nlist()\n```\n:::\n:::\n\n\n\n\n---\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsessionInfo()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nR version 4.3.0 (2023-04-21)\nPlatform: aarch64-apple-darwin20 (64-bit)\nRunning under: macOS Monterey 12.6.2\n\nMatrix products: default\nBLAS:   /Library/Frameworks/R.framework/Versions/4.3-arm64/Resources/lib/libRblas.0.dylib \nLAPACK: /Library/Frameworks/R.framework/Versions/4.3-arm64/Resources/lib/libRlapack.dylib;  LAPACK version 3.11.0\n\nlocale:\n[1] en_GB.UTF-8/en_GB.UTF-8/en_GB.UTF-8/C/en_GB.UTF-8/en_GB.UTF-8\n\ntime zone: Europe/London\ntzcode source: internal\n\nattached base packages:\n[1] stats     graphics  grDevices utils     datasets  methods   base     \n\nother attached packages:\n[1] purrr_1.0.1   tictoc_1.2    ggplot2_3.4.2 furrr_0.3.1   future_1.33.0\n[6] dplyr_1.1.2   dagitty_0.3-1\n\nloaded via a namespace (and not attached):\n [1] utf8_1.2.3        generics_0.1.3    stringi_1.7.12    lattice_0.21-8   \n [5] listenv_0.9.0     digest_0.6.31     magrittr_2.0.3    evaluate_0.21    \n [9] grid_4.3.0        fastmap_1.1.1     Matrix_1.5-4      jsonlite_1.8.5   \n[13] mgcv_1.8-42       fansi_1.0.4       scales_1.2.1      textshaping_0.3.6\n[17] codetools_0.2-19  cli_3.6.1         rlang_1.1.1       parallelly_1.36.0\n[21] munsell_0.5.0     splines_4.3.0     withr_2.5.0       yaml_2.3.7       \n[25] tools_4.3.0       parallel_4.3.0    colorspace_2.1-0  boot_1.3-28.1    \n[29] globals_0.16.2    curl_5.0.0        vctrs_0.6.2       R6_2.5.1         \n[33] lifecycle_1.0.3   stringr_1.5.0     V8_4.3.2          htmlwidgets_1.6.2\n[37] MASS_7.3-58.4     ragg_1.2.5        pkgconfig_2.0.3   pillar_1.9.0     \n[41] gtable_0.3.3      glue_1.6.2        Rcpp_1.0.10       systemfonts_1.0.4\n[45] xfun_0.39         tibble_3.2.1      tidyselect_1.2.0  rstudioapi_0.14  \n[49] knitr_1.43        farver_2.1.1      htmltools_0.5.5   nlme_3.1-162     \n[53] labeling_0.4.2    rmarkdown_2.22    compiler_4.3.0   \n```\n:::\n:::\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}