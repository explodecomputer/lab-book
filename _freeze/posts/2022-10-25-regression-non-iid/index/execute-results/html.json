{
  "hash": "c6e12e2ec7043d7e5fb629b58e69caf2",
  "result": {
    "markdown": "---\ntitle: \"Regression with non i.i.d. samples\"\nauthor: \"Gibran Hemani\"\ndate: \"2022-10-25\"\ncategories: [statistics]\n---\n\n\nIf the individuals in my dataset are correlated with known correlation structure, how can I perform regression whilst accounting for that correlation structure?\n\n\n$$\n\\beta = (X^T \\rho^{-1} X)^{-1} X^T\\rho^{-1}Y\n$$\n\n\nThe variance of the estimate will be\n\n\n$$\n\\begin{aligned}\nVar(\\beta) &= \\sigma^2(X^T \\rho^{-1} X) \\\\\n&= \\frac{(\\hat{e}^T \\rho^{-1} \\hat{e})(X^T \\rho^{-1} X)}{n-r}\n\\end{aligned}\n$$\n\n\nAdding to the complication, in this case it is the h2 estimates of a set of traits being correlated against number of GWAS hits for a set of traits, where the traits are in some way correlated. So the estimates of e.g. h2 are estimated with sampling error, so to account for that perhaps need to parametric bootstrap.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(dplyr)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n\nAttaching package: 'dplyr'\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nThe following objects are masked from 'package:stats':\n\n    filter, lag\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nThe following objects are masked from 'package:base':\n\n    intersect, setdiff, setequal, union\n```\n:::\n\n```{.r .cell-code}\nlibrary(MASS)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n\nAttaching package: 'MASS'\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nThe following object is masked from 'package:dplyr':\n\n    select\n```\n:::\n\n```{.r .cell-code}\nlibrary(mvtnorm)\n\n#' Regression with samples that are not independent\n#'\n#' For our analysis we're regressing estimates against estimates,\n#' and so it's a bit more complicated because the estimates each have an SE.\n#' For now let's just ignore that but I think if we don't account for it we\n#' will get a bit of regression dilution bias.\n#'\n#' @param x Vector of x values\n#' @param y Vector of y values\n#' @param rho correlation matrix\n#' @param se_x SE of x evalues (Ignore)\n#' @param se_y SE of y values (Ignore)\n#' @param nboot Number of bootstraps to get standard error (Ignore)\n#'\n#' @return\n#' @export\nreg_nonind <- function(x, y, rho, se_x=NULL, se_y=NULL, nboot=NULL)\n{\n  X <- cbind(rep(1, length(x)), x)\n  rho_inv <- solve(rho)\n  #beta <- solve(t(X) %*% rho_inv %*% X) %*% t(X) %*% rho_inv %*% y\n  beta <- ginv(t(X)%*%rho_inv %*%X)%*%t(X)%*%rho_inv %*%y\n  yhat <- X %*% beta\n  yres <- as.numeric(y - yhat)\n  se <- as.numeric((t(yres) %*% rho_inv %*% yres) / (length(x)-qr(X)$rank)) * solve(t(X) %*% rho_inv %*% X)\n  se <- sqrt(diag(se))\n  return(tibble(\n    param=c(\"intercept\", \"slope\"), beta=beta, se=se, pval=pnorm(abs(beta)/se, lower.tail=FALSE)\n  ))\n  \n  # get standard error via parametric bootstrap\n  # betaboot <- matrix(0, nboot, 2)\n  # for(i in 1:nboot)\n  # {\n  #   X[,2] <- rnorm(length(x), mean=x, sd=se_x)\n  #   Y <- rnorm(length(y), mean=y, sd=se_y)\n  #   betaboot[i,] <- solve(t(X) %*% rho_inv %*% X) %*% t(X) %*% rho_inv %*% Y %>% as.numeric()\n  # }\n  # se_boot <- apply(betaboot, 2, sd)\n}\n\nx <- runif(300)\ny <- runif(300)\nrho <- diag(300)\nrho[lower.tri(rho)] <- rnorm(sum(lower.tri(rho)), sd=0.01)\nrho[upper.tri(rho)] <- t(rho)[upper.tri(rho)]\n\nreg_nonind(x, y, rho, 10)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 2 Ã— 4\n  param     beta[,1]     se pval[,1]\n  <chr>        <dbl>  <dbl>    <dbl>\n1 intercept   0.507  0.0332 8.42e-53\n2 slope      -0.0522 0.0579 1.84e- 1\n```\n:::\n\n```{.r .cell-code}\nsummary(lm(y~x))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\nCall:\nlm(formula = y ~ x)\n\nResiduals:\n     Min       1Q   Median       3Q      Max \n-0.50453 -0.23397 -0.01499  0.22869  0.51654 \n\nCoefficients:\n            Estimate Std. Error t value Pr(>|t|)    \n(Intercept)  0.51135    0.03319  15.407   <2e-16 ***\nx           -0.05653    0.05748  -0.983    0.326    \n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nResidual standard error: 0.2824 on 298 degrees of freedom\nMultiple R-squared:  0.003235,\tAdjusted R-squared:  -0.0001103 \nF-statistic: 0.967 on 1 and 298 DF,  p-value: 0.3262\n```\n:::\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}