{
  "hash": "cefa122b9dc1c9e09ba82f3285171936",
  "result": {
    "markdown": "---\ntitle: \"Variance QTL using MZs\"\nauthor: Gibran Hemani\ndate: \"2023-02-28\"\ncategories: ['interactions', 'genetics', 'statistics']\n---\n\n\n## Background\n\nData generating model\n\n$$\ny_i = \\alpha + \\beta_{1,j}G_{ij} + z_i + v_i + e_i\n$$\n\nwhere $\\alpha$ is an intercept term, $\\beta_{1,j}$ is the additive effect of SNP \\$j\\$, $G_{i,j}$ is the genotype value for individual $i$ at SNP \\$j\\$, $z_i$ is the remaining polygenic risk\n\n$$\nz_i \\sim N(0, \\sigma^2_{g} - 2p_j(1-p_j)\\beta_{1,j}^2)\n$$\n\n$v_i$ is the SNP's influence on dispersion where\n\n$$\nv_i \\sim N(0, \\beta_{2,j}G_{i,j})\n$$\n\nand $e_i$ is the residual variance\n\n$$\ne_i \\sim N(0, 1 - \\sigma^2_g - \\sigma^2_v)\n$$\n\nTo estimate dispersion effects amongst unrelateds use the deviation regression model (DRM) from Marderstein et al 2021 AJHG (<https://doi.org/10.1016/j.ajhg.2020.11.016>).\n\nTo estimate variance heterogeneity effects using MZs, simply\n\n$$\n|y_{i,A} - y_{i,B}| = \\hat{\\beta}_{2,j}G_{i,j} + \\epsilon_i\n$$\n\nwhere A and B represent the individuals in the MZ pair.\n\nTo estimate variance heterogeneity effects using siblings, it is identical to the MZ method but restricted to sibling pairs who have identity by state value of 2 (i.e. share the same genotype value at the SNP being tested).\n\n## Simulations\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(dplyr)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n\nAttaching package: 'dplyr'\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nThe following objects are masked from 'package:stats':\n\n    filter, lag\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nThe following objects are masked from 'package:base':\n\n    intersect, setdiff, setequal, union\n```\n:::\n\n```{.r .cell-code}\nlibrary(ggplot2)\nlibrary(tidyr)\nlibrary(simulateGP)\n```\n:::\n\n\nMethod for simulating dispersion effects in unrelated individuals\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsim_pop <- function(n, beta1, beta2, af, h2)\n{\n  g <- rbinom(n, 2, af)\n  prs <- g * beta1\n  vg <- rnorm(n, 0, h2)\n  v <- rnorm(n, 0, beta2 * g)\n  ve <- rnorm(n, 0, sqrt(1 - var(vg) - var(v) - var(prs)))\n  y <- prs + v + vg + ve\n  return(tibble(\n    g, y\n  ))\n}\na <- sim_pop(100000, 0.1, 0.5, 0.3, 0.1)\nvar(a)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n           g          y\ng 0.42156007 0.04317622\ny 0.04317622 1.00325833\n```\n:::\n:::\n\n\nMethod for simulating dispersion effects in monozogytic twins\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsim_mz <- function(n, beta1, beta2, af, h2)\n{\n  g <- rbinom(n, 2, af)\n  prs <- g * beta1\n  vg <- rnorm(n, 0, h2)\n  v1 <- rnorm(n, 0, beta2 * g)\n  ve1 <- rnorm(n, 0, sqrt(1 - var(vg) - var(v1) - var(prs)))\n  y1 <- prs + v1 + vg + ve1\n  v2 <- rnorm(n, 0, beta2 * g)\n  ve2 <- rnorm(n, 0, sqrt(1 - var(vg) - var(v2) - var(prs)))\n  y2 <- prs + v2 + vg + ve2\n  return(tibble(\n    g, y1, y2\n  ))\n}\na <- sim_mz(100000, 0.1, 0.5, 0.3, 0.1)\nvar(a)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n            g         y1         y2\ng  0.42132978 0.04268190 0.04133108\ny1 0.04268190 0.99914199 0.01694312\ny2 0.04133108 0.01694312 1.00232809\n```\n:::\n:::\n\n\nSee what dispersion looks like from this simulation\n\n\n::: {.cell}\n\n```{.r .cell-code}\na %>%\n  ggplot(., aes(x=as.factor(g), y=y1)) +\n  geom_boxplot()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-4-1.png){width=672}\n:::\n:::\n\n\nSummarise the dispersion. Note - how would you scale it to the MZ pair mean?\n\n\n::: {.cell}\n\n```{.r .cell-code}\na <- sim_mz(100000, 0.1, 0.5, 0.3, 0.8)\na %>% \n  group_by(g) %>% \n  summarise(\n    m=mean(y1), \n    v=var(y1), \n    mzv=mean(abs(y1-y2))\n  )\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 3 × 4\n      g       m     v   mzv\n  <int>   <dbl> <dbl> <dbl>\n1     0 0.00572 0.799 0.455\n2     1 0.102   1.05  0.720\n3     2 0.193   1.84  1.22 \n```\n:::\n:::\n\n\nMethod for testing unrelateds using DRM\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntest_drm <- function(g, y)\n{\n  y.i <- tapply(y, g, median, na.rm=T)  \n  z.ij <- abs(y - y.i[g+1])\n  summary(lm(z.ij ~ g))$coef %>%\n    as_tibble() %>%\n    slice(2) %>%\n    mutate(method=\"drm\")\n}\ntest_drm(a$g, a$y1)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 1 × 5\n  Estimate `Std. Error` `t value` `Pr(>|t|)` method\n     <dbl>        <dbl>     <dbl>      <dbl> <chr> \n1    0.154      0.00295      52.1          0 drm   \n```\n:::\n:::\n\n\nMethod for testing using MZs\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntest_mz <- function(g, y1, y2)\n{\n  yd1 <- abs(y1-y2)\n  r1 <- summary(lm(yd1 ~ g))$coef %>%\n    as_tibble() %>%\n    slice(2) %>%\n    mutate(method=\"mzdiff\")\n  r1\n}\n\ntest_mz(a$g, a$y1, a$y2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 1 × 5\n  Estimate `Std. Error` `t value` `Pr(>|t|)` method\n     <dbl>        <dbl>     <dbl>      <dbl> <chr> \n1    0.336      0.00250      134.          0 mzdiff\n```\n:::\n:::\n\n\n## Power simulations\n\nA trait with high heritability will have vQTL (dispersion) effects that are relatively large in MZs, but heritability shouldn't have a major part to play in unrelateds for estimating vQTL effects.\n\nStart with simulations where population is compared against mz and n pop = n mz pairs.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nparam <- expand.grid(\n  beta1 = 0,\n  beta2 = seq(0, 0.5, by=0.01),\n  h2 = c(0.1, 0.9),\n  af = 0.3,\n  n = 10000\n)\ndim(param)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 102   5\n```\n:::\n\n```{.r .cell-code}\nres1 <- lapply(1:nrow(param), function(i)\n  {\n  a <- do.call(sim_mz, param[i,])\n  if(any(is.na(a$y1)) | any(is.na(a$y2)))\n  {\n    return(NULL)\n  }\n  bind_rows(\n    test_mz(a$g, a$y1, a$y2),\n    test_drm(a$g, a$y1)\n  ) %>%\n    bind_cols(., param[i,])\n}) %>%\n  bind_rows()\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning in sqrt(1 - var(vg) - var(v1) - var(prs)): NaNs produced\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning in rnorm(n, 0, sqrt(1 - var(vg) - var(v1) - var(prs))): NAs produced\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning in sqrt(1 - var(vg) - var(v2) - var(prs)): NaNs produced\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning in rnorm(n, 0, sqrt(1 - var(vg) - var(v2) - var(prs))): NAs produced\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning in sqrt(1 - var(vg) - var(v1) - var(prs)): NaNs produced\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning in rnorm(n, 0, sqrt(1 - var(vg) - var(v1) - var(prs))): NAs produced\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning in sqrt(1 - var(vg) - var(v2) - var(prs)): NaNs produced\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning in rnorm(n, 0, sqrt(1 - var(vg) - var(v2) - var(prs))): NAs produced\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nres1 %>% filter(n==10000) %>%\nggplot(., aes(x=beta2, y=-log10(`Pr(>|t|)`))) +\n  geom_line(aes(colour=method)) +\n  facet_grid(. ~ h2)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-9-1.png){width=672}\n:::\n:::\n\n\nThey are comparable at low heritability but as heritability increases, MZ method has a distinct advantage.\n\nNow compare with more realistic sample sizes, 10k mz pairs vs 500k unrelateds\n\n\n::: {.cell}\n\n```{.r .cell-code}\nparam <- expand.grid(\n  beta1 = 0,\n  beta2 = seq(0, 0.5, by=0.01),\n  h2 = c(0.1, 0.9),\n  af = 0.32\n)\ndim(param)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 102   4\n```\n:::\n\n```{.r .cell-code}\nres2 <- lapply(1:nrow(param), function(i)\n  {\n  a1 <- do.call(sim_mz, param[i,] %>% mutate(n=10000))\n  a2 <- do.call(sim_mz, param[i,] %>% mutate(n=500000))\n  if(any(is.na(a1$y1)) | any(is.na(a1$y2)) | any(is.na(a2$y1)) | any(is.na(a2$y2)))\n  {\n    return(NULL)\n  }\n  bind_rows(\n    test_mz(a1$g, a1$y1, a1$y2),\n    test_drm(a2$g, a2$y1)\n  ) %>%\n    bind_cols(., param[i,])\n}) %>%\n  bind_rows()\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning in sqrt(1 - var(vg) - var(v1) - var(prs)): NaNs produced\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning in rnorm(n, 0, sqrt(1 - var(vg) - var(v1) - var(prs))): NAs produced\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning in sqrt(1 - var(vg) - var(v2) - var(prs)): NaNs produced\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning in rnorm(n, 0, sqrt(1 - var(vg) - var(v2) - var(prs))): NAs produced\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning in sqrt(1 - var(vg) - var(v1) - var(prs)): NaNs produced\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning in rnorm(n, 0, sqrt(1 - var(vg) - var(v1) - var(prs))): NAs produced\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning in sqrt(1 - var(vg) - var(v2) - var(prs)): NaNs produced\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning in rnorm(n, 0, sqrt(1 - var(vg) - var(v2) - var(prs))): NAs produced\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning in sqrt(1 - var(vg) - var(v1) - var(prs)): NaNs produced\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning in rnorm(n, 0, sqrt(1 - var(vg) - var(v1) - var(prs))): NAs produced\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning in sqrt(1 - var(vg) - var(v2) - var(prs)): NaNs produced\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning in rnorm(n, 0, sqrt(1 - var(vg) - var(v2) - var(prs))): NAs produced\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning in sqrt(1 - var(vg) - var(v1) - var(prs)): NaNs produced\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning in rnorm(n, 0, sqrt(1 - var(vg) - var(v1) - var(prs))): NAs produced\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning in sqrt(1 - var(vg) - var(v2) - var(prs)): NaNs produced\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning in rnorm(n, 0, sqrt(1 - var(vg) - var(v2) - var(prs))): NAs produced\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning in sqrt(1 - var(vg) - var(v1) - var(prs)): NaNs produced\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning in rnorm(n, 0, sqrt(1 - var(vg) - var(v1) - var(prs))): NAs produced\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning in sqrt(1 - var(vg) - var(v2) - var(prs)): NaNs produced\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning in rnorm(n, 0, sqrt(1 - var(vg) - var(v2) - var(prs))): NAs produced\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning in sqrt(1 - var(vg) - var(v1) - var(prs)): NaNs produced\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning in rnorm(n, 0, sqrt(1 - var(vg) - var(v1) - var(prs))): NAs produced\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning in sqrt(1 - var(vg) - var(v2) - var(prs)): NaNs produced\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning in rnorm(n, 0, sqrt(1 - var(vg) - var(v2) - var(prs))): NAs produced\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning in sqrt(1 - var(vg) - var(v1) - var(prs)): NaNs produced\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning in rnorm(n, 0, sqrt(1 - var(vg) - var(v1) - var(prs))): NAs produced\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning in sqrt(1 - var(vg) - var(v2) - var(prs)): NaNs produced\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning in rnorm(n, 0, sqrt(1 - var(vg) - var(v2) - var(prs))): NAs produced\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(res2, aes(x=beta2, y=-log10(`Pr(>|t|)`))) +\n  geom_line(aes(colour=method)) +\n  facet_grid(. ~ h2)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-11-1.png){width=672}\n:::\n:::\n\n\nIt looks like you'd just be better off with estimation in populations.\n\n## Type 1 error\n\n\n::: {.cell}\n\n```{.r .cell-code}\nparam <- expand.grid(\n  beta1 = seq(0, 0.5, by=0.002),\n  beta2 = 0,\n  h2 = c(0.1, 0.9),\n  af = 0.32\n)\ndim(param)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 502   4\n```\n:::\n\n```{.r .cell-code}\nres3 <- lapply(1:nrow(param), function(i)\n  {\n  a1 <- do.call(sim_mz, param[i,] %>% mutate(n=10000))\n  a2 <- do.call(sim_mz, param[i,] %>% mutate(n=500000))\n  if(any(is.na(a1$y1)) | any(is.na(a1$y2)) | any(is.na(a2$y1)) | any(is.na(a2$y2)))\n  {\n    return(NULL)\n  }\n  bind_rows(\n    test_mz(a1$g, a1$y1, a1$y2),\n    test_drm(a2$g, a2$y1)\n  ) %>%\n    bind_cols(., param[i,])\n}) %>%\n  bind_rows()\n```\n:::\n\n\nPlot type 1 error\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(res3, aes(x=beta1, y=-log10(`Pr(>|t|)`))) +\n  geom_line(aes(colour=method)) +\n  facet_grid(. ~ h2)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-13-1.png){width=672}\n:::\n:::\n\n\nType 1 error and number of false positives after multiple testing correction\n\n\n::: {.cell}\n\n```{.r .cell-code}\nres3 %>% \n  mutate(fdr=p.adjust(`Pr(>|t|)`, \"fdr\")) %>%\n  group_by(method, h2) %>%\n  summarise(\n    t1 = sum(`Pr(>|t|)` < 0.05, na.rm=T)/sum(!is.na(`Pr(>|t|)`)),\n    nfdr = sum(fdr < 0.05)/sum(!is.na(`Pr(>|t|)`))\n  )\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n`summarise()` has grouped output by 'method'. You can override using the\n`.groups` argument.\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 4 × 4\n# Groups:   method [2]\n  method    h2     t1  nfdr\n  <chr>  <dbl>  <dbl> <dbl>\n1 drm      0.1 0.0478     0\n2 drm      0.9 0.0438     0\n3 mzdiff   0.1 0.0558     0\n4 mzdiff   0.9 0.0398     0\n```\n:::\n:::\n\n\nUnder normal distribution type-1 error rate is well controlled.\n\n## Simulations using siblings\n\nGenerate a set of sib pairs with the following specification\n\n-   Have PRS such that IBD \\~ N(0.5, sqrt(0.037))\n\n-   h2 specified\n\n-   ce specified (shared variance between sibs\n\n-   one SNP has a mean and variance effect\n\n-   scaled phenotypes \\~ N(0, 1)\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsim_sibs <- function(af, nfam, beta1, beta2, h2, c2)\n{\n  # Choose number of SNPs to be expected number of recombination events\n  # in order to give appropriate distribution of IBD\n\tnsnp <- 87\n\taf <- rep(af, nsnp)\n\tdads <- matrix(0, nfam, nsnp)\n\tmums <- matrix(0, nfam, nsnp)\n\tsibs1 <- matrix(0, nfam, nsnp)\n\tsibs2 <- matrix(0, nfam, nsnp)\n\tibd <- matrix(0, nfam, nsnp)\n\tibs <- matrix(0, nfam, nsnp)\n\tfor(i in 1:nsnp)\n\t{\n\t\tdad1 <- rbinom(nfam, 1, af[i]) + 1\n\t\tdad2 <- (rbinom(nfam, 1, af[i]) + 1) * -1\n\t\tmum1 <- rbinom(nfam, 1, af[i]) + 1\n\t\tmum2 <- (rbinom(nfam, 1, af[i]) + 1) * -1\n\n\t\tdadindex <- sample(c(TRUE, FALSE), nfam, replace=TRUE)\n\t\tdadh <- rep(NA, nfam)\n\t\tdadh[dadindex] <- dad1[dadindex]\n\t\tdadh[!dadindex] <- dad2[!dadindex]\n\n\t\tmumindex <- sample(c(TRUE, FALSE), nfam, replace=TRUE)\n\t\tmumh <- rep(NA, nfam)\n\t\tmumh[mumindex] <- mum1[mumindex]\n\t\tmumh[!mumindex] <- mum2[!mumindex]\n\n\t\tsib1 <- cbind(dadh, mumh)\n\n\t\tdadindex <- sample(c(TRUE, FALSE), nfam, replace=TRUE)\n\t\tdadh <- rep(NA, nfam)\n\t\tdadh[dadindex] <- dad1[dadindex]\n\t\tdadh[!dadindex] <- dad2[!dadindex]\n\n\t\tmumindex <- sample(c(TRUE, FALSE), nfam, replace=TRUE)\n\t\tmumh <- rep(NA, nfam)\n\t\tmumh[mumindex] <- mum1[mumindex]\n\t\tmumh[!mumindex] <- mum2[!mumindex]\n\n\t\tsib2 <- cbind(dadh, mumh)\n\n\t\tibd[,i] <- (as.numeric(sib1[,1] == sib2[,1]) + as.numeric(sib1[,2] == sib2[,2])) / 2\n\n\t\tsibs1[,i] <- rowSums(abs(sib1) - 1)\n\t\tsibs2[,i] <- rowSums(abs(sib2) - 1)\n\t\tdads[,i] <- dad1 - 1 + abs(dad2) - 1\n\t\tmums[,i] <- mum1 - 1 + abs(mum2) - 1\n\n\t\t# l[[i]] <- (sum(sib1[,1] == sib2[,1]) / nsnp + sum(sib1[,2] == sib2[,2]) / nsnp) / 2\n\n\t}\n\tn <- nfam\n\t# Make phenotypes\n\tce <- rnorm(n, 0, sqrt(c2))\n\tv1 <- rnorm(n, 0, beta2 * sibs1[,1])\n\tv2 <- rnorm(n, 0, beta2 * sibs2[,1])\n\te1 <- rnorm(n, 0, sqrt(1 - h2 - c2 - var(v1)))\n\te2 <- rnorm(n, 0, sqrt(1 - h2 - c2 - var(v2)))\n\tb <- rnorm(nsnp-1, 0, 1)\n\th2_1 <- beta1^2 * af[1] * (1-af[1]) * 2\n\th2_res <- h2 - h2_1\n\tprs1 <- scale(sibs1[,-1] %*% b) * sqrt(h2_res)\n\tprs2 <- scale(sibs2[,-1] %*% b) * sqrt(h2_res)\n\ty1 <- sibs1[,1] * beta1 + prs1 + v1 + ce + e1\n\ty2 <- sibs2[,1] * beta1 + prs2 + v2 + ce + e2\n\treturn(tibble(\n\t  ibd = rowMeans(ibd),\n\t  g1 = sibs1[,1],\n\t  g2 = sibs2[,1],\n\t  prs1,\n\t  prs2,\n\t  y1, \n\t  y2\n\t))\n}\n```\n:::\n\n\nNotes\n\n-   In this model if the allele frequency is higher, then the genotype class with the larger variance is more common, which means that effect alleles are not reflexive in terms of variances\n\n-   I think this use with siblings may have problems due to LD. If there is incomplete LD with another causal variant elsewhere close by then the mean effect of that causal variant will contribute to the variance effect estimated at the variant\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfam <- sim_sibs(0.3, 10000, 0.1, 0.4, 0.6, 0.1)\ncor(fam) %>% round(4)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n         ibd      g1      g2    prs1   prs2      y1     y2\nibd   1.0000 -0.0032 -0.0183 -0.0068 0.0024 -0.0020 0.0062\ng1   -0.0032  1.0000  0.4970  0.0130 0.0195  0.0704 0.0395\ng2   -0.0183  0.4970  1.0000  0.0074 0.0160  0.0434 0.0750\nprs1 -0.0068  0.0130  0.0074  1.0000 0.5023  0.7720 0.3840\nprs2  0.0024  0.0195  0.0160  0.5023 1.0000  0.4043 0.7777\ny1   -0.0020  0.0704  0.0434  0.7720 0.4043  1.0000 0.4139\ny2    0.0062  0.0395  0.0750  0.3840 0.7777  0.4139 1.0000\n```\n:::\n:::\n\n\nNow how to estimate variance effect? At a locus restrict to sib pairs who are IBD = 1\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfam <- sim_sibs(af=0.5, nfam=40000, beta1=0.1, beta2=0.2, h2=0.3, c2=0.1)\nfam\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 40,000 × 7\n     ibd    g1    g2 prs1[,1] prs2[,1]  y1[,1]  y2[,1]\n   <dbl> <dbl> <dbl>    <dbl>    <dbl>   <dbl>   <dbl>\n 1 0.477     0     2   0.542    0.307   0.958  -0.0552\n 2 0.552     1     1   0.0251  -0.459   0.888  -0.675 \n 3 0.5       1     1  -0.254   -0.164  -1.38   -0.596 \n 4 0.517     1     0   0.252   -0.522   1.72   -0.171 \n 5 0.517     1     1  -0.197   -0.183   0.343  -1.36  \n 6 0.534     1     1   0.838    0.526   1.03    1.16  \n 7 0.483     0     0   0.383   -0.524  -0.974  -0.727 \n 8 0.5       2     1  -0.291   -0.291   0.0133 -0.884 \n 9 0.534     1     1   0.310   -0.627   0.362  -0.852 \n10 0.494     0     0   0.576    0.0136  1.06   -1.01  \n# … with 39,990 more rows\n```\n:::\n:::\n\n\nTest for variance QTL\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfam <- sim_sibs(af=0.5, nfam=40000, beta1=0.1, beta2=0.2, h2=0.01, c2=0.01)\nf1 <- subset(fam, g1==g2)\ntest_mz(f1$g1, f1$y1, f1$y2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 1 × 5\n  Estimate `Std. Error` `t value`   `Pr(>|t|)` method\n     <dbl>        <dbl>     <dbl>        <dbl> <chr> \n1   0.0438      0.00798      5.50 0.0000000394 mzdiff\n```\n:::\n:::\n\n\nPower sims\n\n\n::: {.cell}\n\n```{.r .cell-code}\nparam <- expand.grid(\n  beta1 = 0,\n  beta2 = seq(0, 0.5, by=0.01),\n  c2 = c(0),\n  h2 = c(0.1, 0.5),\n  af = c(0.5)\n)\ndim(param)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 102   5\n```\n:::\n\n```{.r .cell-code}\nres4 <- lapply(1:nrow(param), function(i)\n  {\n  a1 <- do.call(sim_sibs, param[i,] %>% mutate(nfam=22000))\n  a2 <- do.call(sim_pop, param[i,] %>% select(-c(c2)) %>% mutate(n=500000))\n  if(any(is.na(a1$y1)) | any(is.na(a1$y2)) | any(is.na(a2$y)))\n  {\n    return(NULL)\n  }\n  bind_rows(\n    a1 %>% filter(g1==g2) %>% select(g=g1, y1, y2) %>% do.call(test_mz, .),\n    do.call(test_drm, a2)\n  ) %>%\n    bind_cols(., param[i,])\n}) %>%\n  bind_rows()\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nres4 %>% mutate(sharing=c2+h2) %>% filter(beta1==0) %>%\n  ggplot(., aes(x=beta2, y=-log10(`Pr(>|t|)`))) +\n  geom_line(aes(colour=method, groups=af)) +\n  facet_grid(. ~ sharing)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning in geom_line(aes(colour = method, groups = af)): Ignoring unknown\naesthetics: groups\n```\n:::\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-20-1.png){width=672}\n:::\n:::\n\n\nSimilar to MZ method - quite a substantial benefit from leveraging large sample sizes of unrelateds compared to using siblings.\n\n## SVLM\n\nAdjust the phenotype for covariates + genotype, square residuals and then test in linear model against genotype.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntest_svlm <- function(g, y)\n{\n  yres <- residuals(lm(y ~ g))^2\n  summary(lm(yres ~ g))$coefficients %>%\n    as_tibble() %>%\n    slice(n=2) %>%\n    mutate(method=\"svlm\")\n}\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nn <- 10000\ng1 <- rbinom(n, 2, 0.4)\ng2 <- rbinom(n, 2, 0.4)\ny <- g1 + g2 + g1 * g2\nbind_rows(\n  test_drm(g1, y),\n  test_svlm(g1, y)\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 2 × 5\n  Estimate `Std. Error` `t value` `Pr(>|t|)` method\n     <dbl>        <dbl>     <dbl>      <dbl> <chr> \n1    0.524       0.0139      37.7  2.06e-291 drm   \n2    1.85        0.0333      55.7  0         svlm  \n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ny <- g1 + g2 + rnorm(n)\nbind_rows(\n  test_drm(g1, y),\n  test_svlm(g1, y)\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 2 × 5\n  Estimate `Std. Error` `t value` `Pr(>|t|)` method\n     <dbl>        <dbl>     <dbl>      <dbl> <chr> \n1 0.000577       0.0104    0.0557      0.956 drm   \n2 0.00402        0.0286    0.141       0.888 svlm  \n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ny <- g1 + g2 + g1 * g2\nyres <- residuals(lm(y ~ g1 + g2))^2\nsummary(lm(yres ~ g1))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\nCall:\nlm(formula = yres ~ g1)\n\nResiduals:\n    Min      1Q  Median      3Q     Max \n-0.2912 -0.2516 -0.1973  0.2402  1.7333 \n\nCoefficients:\n            Estimate Std. Error t value Pr(>|t|)    \n(Intercept) 0.155064   0.006387   24.28   <2e-16 ***\ng1          0.097849   0.006041   16.20   <2e-16 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nResidual standard error: 0.4188 on 9998 degrees of freedom\nMultiple R-squared:  0.02557,\tAdjusted R-squared:  0.02547 \nF-statistic: 262.4 on 1 and 9998 DF,  p-value: < 2.2e-16\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nyres <- residuals(lm(y ~ g1))^2\nsummary(lm(yres ~ g1))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\nCall:\nlm(formula = yres ~ g1)\n\nResiduals:\n    Min      1Q  Median      3Q     Max \n-3.6900 -2.0229  0.2948  0.3860  8.8235 \n\nCoefficients:\n            Estimate Std. Error t value Pr(>|t|)    \n(Intercept)  0.32939    0.03516   9.368   <2e-16 ***\ng1           1.85174    0.03325  55.686   <2e-16 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nResidual standard error: 2.305 on 9998 degrees of freedom\nMultiple R-squared:  0.2367,\tAdjusted R-squared:  0.2367 \nF-statistic:  3101 on 1 and 9998 DF,  p-value: < 2.2e-16\n```\n:::\n:::\n\n\n## Inflation due to LD\n\n\n::: {.cell}\n\n```{.r .cell-code}\nres <- sapply(1:1000, function(i){\n  g <- correlated_binomial(n, 0.5, 0.5, 0.8)\n  g2 <- rbinom(n, 2, 0.5)\n  y <- g[,1] + rnorm(n)\n  summary(lm(y ~ g[,2]*g2))$coef[4,4] \n})\nhist(res)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-26-1.png){width=672}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ngendatp <- function(n, p1, p2, p3, r1)\n{\n\t# dat <- simulateGP:::simulate_geno(n, r1, p1, p2) %>% as_tibble\n\tdat <- correlated_binomial(n, p1, p2, r1) %>% as_tibble()\n\tnames(dat) <- c(\"y1\", \"y2\")\n\tdat$y3 <- rbinom(n, 1, p3)\n\treturn(dat)\n}\n\nrun_simp <- function(param, i)\n{\n\tset.seed(i*10)\n\tdat <- gendatp(param$n[i], param$p1[i], param$p2[i], param$p3[i], param$r1[i])\n\tx <- dat$y1 + rnorm(nrow(dat), sd=sd(dat$y1)/2)\n\tmod1 <- lm(x ~ y2 + y3, dat)\n\tmod2 <- lm(x ~ y2 + y3 + y2*y3, dat)\n\tamod <- anova(mod1, mod2)\n\tparam$F[i] <- amod$F[2]\n\to1 <- test_drm(dat$y1, x)\n\to2 <- test_drm(dat$y2, x)\n\to3 <- test_drm(dat$y3, x)\n\tparam$drm1[i] <- o1$`Pr(>|t|)`\n\tparam$drm2[i] <- o2$`Pr(>|t|)`\n\tparam$drm3[i] <- o3$`Pr(>|t|)`\n\treturn(param[i,])\n}\nparam <- expand.grid(\n\tp1=0.1,\n\tp2=0.1,\n\tp3=0.5,\n\tp4=0.1,\n\tn=1000,\n\tr1=seq(0, 1, by=0.2),\n\tsim=1:100,\n\tr2=NA,\n\tF=NA,\n\tdrm1=NA,\n\tdrm2=NA,\n\tdrm3=NA\n)\nresp <- lapply(1:nrow(param), function(x) run_simp(param, x)) %>% bind_rows()\nstr(resp)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n'data.frame':\t600 obs. of  12 variables:\n $ p1  : num  0.1 0.1 0.1 0.1 0.1 0.1 0.1 0.1 0.1 0.1 ...\n $ p2  : num  0.1 0.1 0.1 0.1 0.1 0.1 0.1 0.1 0.1 0.1 ...\n $ p3  : num  0.5 0.5 0.5 0.5 0.5 0.5 0.5 0.5 0.5 0.5 ...\n $ p4  : num  0.1 0.1 0.1 0.1 0.1 0.1 0.1 0.1 0.1 0.1 ...\n $ n   : num  1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 ...\n $ r1  : num  0 0.2 0.4 0.6 0.8 1 0 0.2 0.4 0.6 ...\n $ sim : int  1 1 1 1 1 1 2 2 2 2 ...\n $ r2  : logi  NA NA NA NA NA NA ...\n $ F   : num  0.548 2.737 2.562 0.187 2.62 ...\n $ drm1: num  0.288 0.376 0.16 0.215 0.998 ...\n $ drm2: num  3.24e-02 1.39e-15 8.30e-18 1.03e-20 2.35e-14 ...\n $ drm3: num  0.9173 0.1256 0.0146 0.1303 0.6663 ...\n - attr(*, \"out.attrs\")=List of 2\n  ..$ dim     : Named int [1:12] 1 1 1 1 1 6 100 1 1 1 ...\n  .. ..- attr(*, \"names\")= chr [1:12] \"p1\" \"p2\" \"p3\" \"p4\" ...\n  ..$ dimnames:List of 12\n  .. ..$ p1  : chr \"p1=0.1\"\n  .. ..$ p2  : chr \"p2=0.1\"\n  .. ..$ p3  : chr \"p3=0.5\"\n  .. ..$ p4  : chr \"p4=0.1\"\n  .. ..$ n   : chr \"n=1000\"\n  .. ..$ r1  : chr [1:6] \"r1=0.0\" \"r1=0.2\" \"r1=0.4\" \"r1=0.6\" ...\n  .. ..$ sim : chr [1:100] \"sim=  1\" \"sim=  2\" \"sim=  3\" \"sim=  4\" ...\n  .. ..$ r2  : chr \"r2=NA\"\n  .. ..$ F   : chr \"F=NA\"\n  .. ..$ drm1: chr \"drm1=NA\"\n  .. ..$ drm2: chr \"drm2=NA\"\n  .. ..$ drm3: chr \"drm3=NA\"\n```\n:::\n:::\n\n\nResult using the actual causal variant\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(resp, aes(x=r1, y=-log10(drm1))) +\ngeom_boxplot(aes(fill=as.factor(r1))) +\nscale_fill_brewer(type=\"seq\") +\nlabs(y=\"DRM -log10 p\", x=\"Measurement precision of causal additive variant\", fill=\"LD between tagging\\nvariant and causal variant\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-28-1.png){width=672}\n:::\n:::\n\n\nResult using\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(resp, aes(x=r1, y=-log10(drm2))) +\ngeom_boxplot(aes(fill=as.factor(r1))) +\nscale_fill_brewer(type=\"seq\") +\nlabs(y=\"DRM -log10 p\", x=\"Measurement precision of causal additive variant\", fill=\"LD between tagging\\nvariant and causal variant\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-29-1.png){width=672}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(resp, aes(x=r1, y=-log10(drm3))) +\ngeom_boxplot(aes(fill=as.factor(r1))) +\nscale_fill_brewer(type=\"seq\") +\nlabs(y=\"DRM -log10 p\", x=\"Measurement precision of causal additive variant\", fill=\"LD between tagging\\nvariant and causal variant\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-30-1.png){width=672}\n:::\n:::\n\n\n\nLD issue persists with MZ analysis?\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsim_mz2 <- function(g, beta1, beta2, h2)\n{\n  n <- length(g)\n  prs <- g * beta1\n  vg <- rnorm(n, 0, h2)\n  v1 <- rnorm(n, 0, beta2 * g)\n  ve1 <- rnorm(n, 0, sqrt(1 - var(vg) - var(v1) - var(prs)))\n  y1 <- prs + v1 + vg + ve1\n  v2 <- rnorm(n, 0, beta2 * g)\n  ve2 <- rnorm(n, 0, sqrt(1 - var(vg) - var(v2) - var(prs)))\n  y2 <- prs + v2 + vg + ve2\n  return(tibble(\n    g, y1, y2\n  ))\n}\n\ntest_mz <- function(g, y1, y2)\n{\n  yd1 <- abs(y1-y2)\n  r1 <- summary(lm(yd1 ~ g))$coef %>%\n    as_tibble() %>%\n    slice(2) %>%\n    mutate(method=\"mzdiff\")\n  r1\n}\n\ngendatp <- function(n, p1, p2, p3, r1)\n{\n\t# dat <- simulateGP:::simulate_geno(n, r1, p1, p2) %>% as_tibble\n\tdat <- correlated_binomial(n, p1, p2, r1) %>% as_tibble()\n\tnames(dat) <- c(\"g1\", \"g2\")\n\tdat$g3 <- rbinom(n, 1, p3)\n\treturn(dat)\n}\n\nrun_simp_mz <- function(param, i)\n{\n\tset.seed(i*10)\n\tdat <- gendatp(param$n[i], param$p1[i], param$p2[i], param$p3[i], param$r1[i])\n\tmzdat <- sim_mz2(dat$g1, param$beta1[i], param$beta2[i], param$h2)\n\t#x <- dat$y1 + rnorm(nrow(dat), sd=sd(dat$y1)/2)\n\to1 <- test_drm(dat$g1, mzdat$y1)\n\to2 <- test_drm(dat$g2, mzdat$y1)\n\to3 <- test_drm(dat$g3, mzdat$y1)\n\tm1 <- test_mz(dat$g1, mzdat$y1, mzdat$y2)\n\tm2 <- test_mz(dat$g2, mzdat$y1, mzdat$y2)\n\tm3 <- test_mz(dat$g3, mzdat$y1, mzdat$y2)\n\tparam$drm1[i] <- o1$`Pr(>|t|)`\n\tparam$drm2[i] <- o2$`Pr(>|t|)`\n\tparam$drm3[i] <- o3$`Pr(>|t|)`\n\tparam$mz1[i] <- m1$`Pr(>|t|)`\n\tparam$mz2[i] <- m2$`Pr(>|t|)`\n\tparam$mz3[i] <- m3$`Pr(>|t|)`\n\treturn(param[i,])\n}\n\nparam <- expand.grid(\n\tp1=0.1,\n\tp2=0.1,\n\tp3=0.5,\n\tp4=0.1,\n\tn=1000,\n\tr1=seq(0, 1, by=0.2),\n\tbeta1=1,\n\tbeta2=0,\n\th2=0.5,\n\tsim=1:500,\n\tr2=NA,\n\tF=NA,\n\tdrm1=NA,\n\tdrm2=NA,\n\tdrm3=NA,\n\tmz1=NA,\n\tmz2=NA,\n\tmz3=NA\n)\n\nresmz <- lapply(1:nrow(param), function(i) run_simp_mz(param, i)) %>% bind_rows()\nresmz %>% str\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n'data.frame':\t3000 obs. of  18 variables:\n $ p1   : num  0.1 0.1 0.1 0.1 0.1 0.1 0.1 0.1 0.1 0.1 ...\n $ p2   : num  0.1 0.1 0.1 0.1 0.1 0.1 0.1 0.1 0.1 0.1 ...\n $ p3   : num  0.5 0.5 0.5 0.5 0.5 0.5 0.5 0.5 0.5 0.5 ...\n $ p4   : num  0.1 0.1 0.1 0.1 0.1 0.1 0.1 0.1 0.1 0.1 ...\n $ n    : num  1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 ...\n $ r1   : num  0 0.2 0.4 0.6 0.8 1 0 0.2 0.4 0.6 ...\n $ beta1: num  1 1 1 1 1 1 1 1 1 1 ...\n $ beta2: num  0 0 0 0 0 0 0 0 0 0 ...\n $ h2   : num  0.5 0.5 0.5 0.5 0.5 0.5 0.5 0.5 0.5 0.5 ...\n $ sim  : int  1 1 1 1 1 1 2 2 2 2 ...\n $ r2   : logi  NA NA NA NA NA NA ...\n $ F    : logi  NA NA NA NA NA NA ...\n $ drm1 : num  0.717 0.117 0.951 0.239 0.899 ...\n $ drm2 : num  0.381 0.134 0.584 0.55 0.456 ...\n $ drm3 : num  0.587 0.158 0.228 0.775 0.928 ...\n $ mz1  : num  0.3104 0.0677 0.9304 0.1766 0.1589 ...\n $ mz2  : num  0.5393 0.2663 0.1479 0.0585 0.7089 ...\n $ mz3  : num  0.483 0.977 0.943 0.169 0.369 ...\n - attr(*, \"out.attrs\")=List of 2\n  ..$ dim     : Named int [1:18] 1 1 1 1 1 6 1 1 1 500 ...\n  .. ..- attr(*, \"names\")= chr [1:18] \"p1\" \"p2\" \"p3\" \"p4\" ...\n  ..$ dimnames:List of 18\n  .. ..$ p1   : chr \"p1=0.1\"\n  .. ..$ p2   : chr \"p2=0.1\"\n  .. ..$ p3   : chr \"p3=0.5\"\n  .. ..$ p4   : chr \"p4=0.1\"\n  .. ..$ n    : chr \"n=1000\"\n  .. ..$ r1   : chr [1:6] \"r1=0.0\" \"r1=0.2\" \"r1=0.4\" \"r1=0.6\" ...\n  .. ..$ beta1: chr \"beta1=1\"\n  .. ..$ beta2: chr \"beta2=0\"\n  .. ..$ h2   : chr \"h2=0.5\"\n  .. ..$ sim  : chr [1:500] \"sim=  1\" \"sim=  2\" \"sim=  3\" \"sim=  4\" ...\n  .. ..$ r2   : chr \"r2=NA\"\n  .. ..$ F    : chr \"F=NA\"\n  .. ..$ drm1 : chr \"drm1=NA\"\n  .. ..$ drm2 : chr \"drm2=NA\"\n  .. ..$ drm3 : chr \"drm3=NA\"\n  .. ..$ mz1  : chr \"mz1=NA\"\n  .. ..$ mz2  : chr \"mz2=NA\"\n  .. ..$ mz3  : chr \"mz3=NA\"\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(resmz, aes(x=r1, y=-log10(drm2))) +\ngeom_boxplot(aes(fill=as.factor(r1))) +\nscale_fill_brewer(type=\"seq\") +\nlabs(y=\"DRM -log10 p\", x=\"LD between tagging\\nvariant and causal variant\", fill=\"LD\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-32-1.png){width=672}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nresmz %>% \n  dplyr::select(r1, MZ=mz2, pop=drm2) %>% gather(., \"key\", \"value\", MZ, pop) %>%\n  ggplot(., aes(x=r1, y=-log10(value))) +\n  geom_boxplot(aes(fill=as.factor(r1))) +\n  scale_fill_brewer(type=\"seq\") +\n  facet_grid(. ~ key) +\n  labs(y=\"MZ dispersion -log10 p\", x=\"LD between tagging\\nvariant and causal variant\", fill=\"LD\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-33-1.png){width=672}\n:::\n:::\n\n\n\n## Summary\n\n- Using MZs is better powered than populations given equal sample sizes especially when h2 is large, but population sample sizes can be much larger which outweighs the power advantage of MZs\n- MZs restricted to GxE or true variance heterogeneity (no GxG)\n- MZs not liable to the LD leakage issue\n- Using DZs at loci where IBD=1 is possible which could boost power\n- Could expand DZ model to all loci but would need to generate model appropriately.\n\n---\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsessionInfo()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nR version 4.2.1 Patched (2022-09-06 r82817)\nPlatform: aarch64-apple-darwin20 (64-bit)\nRunning under: macOS Monterey 12.6.2\n\nMatrix products: default\nBLAS:   /Library/Frameworks/R.framework/Versions/4.2-arm64/Resources/lib/libRblas.0.dylib\nLAPACK: /Library/Frameworks/R.framework/Versions/4.2-arm64/Resources/lib/libRlapack.dylib\n\nlocale:\n[1] en_GB.UTF-8/en_GB.UTF-8/en_GB.UTF-8/C/en_GB.UTF-8/en_GB.UTF-8\n\nattached base packages:\n[1] stats     graphics  grDevices utils     datasets  methods   base     \n\nother attached packages:\n[1] simulateGP_0.1.2 tidyr_1.2.1      ggplot2_3.4.0    dplyr_1.0.10    \n\nloaded via a namespace (and not attached):\n [1] RColorBrewer_1.1-3 pillar_1.8.1       compiler_4.2.1     tools_4.2.1       \n [5] digest_0.6.31      jsonlite_1.8.4     evaluate_0.19      lifecycle_1.0.3   \n [9] tibble_3.1.8       gtable_0.3.1       pkgconfig_2.0.3    rlang_1.0.6       \n[13] DBI_1.1.3          cli_3.5.0          yaml_2.3.6         xfun_0.36         \n[17] fastmap_1.1.0      withr_2.5.0        stringr_1.5.0      knitr_1.41        \n[21] generics_0.1.3     vctrs_0.5.1        htmlwidgets_1.5.4  grid_4.2.1        \n[25] tidyselect_1.2.0   glue_1.6.2         R6_2.5.1           fansi_1.0.3       \n[29] rmarkdown_2.16     farver_2.1.1       purrr_1.0.0        magrittr_2.0.3    \n[33] ellipsis_0.3.2     scales_1.2.1       htmltools_0.5.4    assertthat_0.2.1  \n[37] colorspace_2.0-3   labeling_0.4.2     utf8_1.2.2         stringi_1.7.8     \n[41] munsell_0.5.0     \n```\n:::\n:::\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}