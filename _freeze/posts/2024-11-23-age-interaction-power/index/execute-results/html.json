{
  "hash": "c7015263ceafcbef43e5180126b915ce",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Power of G x age interactions\"\nauthor: Gibran Hemani\ndate: \"2024-11-23\"\ncategories: []\n---\n\n\n## Background\n\nIndividual level analysis versus age-stratified GWAS to detect GxAge interactions\n\n## Simulation setup\n\n\nThe simulation is based on the following model:\n\n$$\ny_i = \\beta_0 g + \\beta_1 g_i \\times a_i + \\beta_2 g_i \\times a_i^2 + \\beta_3 g_i \\times a_i^3 + e_i\n$$\n\nwhere $y_i$ is the phenotype of individual $i$, $g_i$ is the genotype, $a_i$ is the age normalised to have range $(-1,1)$, and $e_i$ is the error term. \n\nThe simulation is based on the following steps:\n\n1. Generate a set of coefficients for the age polynomial\n2. Generate a set of individuals with age, genotype, and error terms\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(dplyr)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\n\nAttaching package: 'dplyr'\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nThe following objects are masked from 'package:stats':\n\n    filter, lag\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nThe following objects are masked from 'package:base':\n\n    intersect, setdiff, setequal, union\n```\n\n\n:::\n\n```{.r .cell-code}\nlibrary(metafor)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nLoading required package: Matrix\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nLoading required package: metadat\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nLoading required package: numDeriv\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\n\nLoading the 'metafor' package (version 4.6-0). For an\nintroduction to the package please type: help(metafor)\n```\n\n\n:::\n\n```{.r .cell-code}\nlibrary(rms)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nLoading required package: Hmisc\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\n\nAttaching package: 'Hmisc'\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nThe following objects are masked from 'package:dplyr':\n\n    src, summarize\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nThe following objects are masked from 'package:base':\n\n    format.pval, units\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\n\nAttaching package: 'rms'\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nThe following object is masked from 'package:metafor':\n\n    vif\n```\n\n\n:::\n\n```{.r .cell-code}\nsimdat <- function(n=500000, b0, b1, b2, b3) { \n    nage <- length(40:70)\n    coef <- tibble(\n        age = 40:70,\n        x = seq(-1, 1, length.out=nage),\n        bxage = x^3 * b3 + x^2 * b2 + x * b1 + b0\n    )\n\n    dat <- tibble(\n        age = runif(n, 40, 70) %>% round,\n        g = rbinom(n, 2, 0.5),\n        e = rnorm(n)\n    ) %>% group_by(age) %>%\n        do({\n            a <- subset(coef, age == .$age[1])\n            mutate(., prs = a$bxage * g, y = prs + e)\n        })\n\n    return(list(dat=dat, coef=coef))\n}\n```\n:::\n\n\nAn example of the simulation with **no interaction**:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsim <- simdat(500000, 0.02, 0, 0, 0)\nsim\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n$dat\n# A tibble: 500,000 × 5\n# Groups:   age [31]\n     age     g       e   prs       y\n   <dbl> <int>   <dbl> <dbl>   <dbl>\n 1    40     0 -0.777   0    -0.777 \n 2    40     1 -0.154   0.02 -0.134 \n 3    40     1  0.217   0.02  0.237 \n 4    40     2  1.32    0.04  1.36  \n 5    40     1  0.554   0.02  0.574 \n 6    40     2 -0.739   0.04 -0.699 \n 7    40     2  1.67    0.04  1.71  \n 8    40     1  0.226   0.02  0.246 \n 9    40     0 -0.388   0    -0.388 \n10    40     0  0.0369  0     0.0369\n# ℹ 499,990 more rows\n\n$coef\n# A tibble: 31 × 3\n     age      x bxage\n   <int>  <dbl> <dbl>\n 1    40 -1      0.02\n 2    41 -0.933  0.02\n 3    42 -0.867  0.02\n 4    43 -0.8    0.02\n 5    44 -0.733  0.02\n 6    45 -0.667  0.02\n 7    46 -0.6    0.02\n 8    47 -0.533  0.02\n 9    48 -0.467  0.02\n10    49 -0.4    0.02\n# ℹ 21 more rows\n```\n\n\n:::\n:::\n\n\nEstimation is performed by \n\n1. generating summary statistics for 2-year age bins\n2. estimating the effects of the genotype on the phenotype in each age bin using a simple linear model\n3. performing a polynomial meta regression of \n\n$$\n\\beta_{age} \\sim age + age^2 + age^3\n$$\n\nAn example of the model fit is shown below:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsumstats <- function(dat) {\n    # split dat into 2 year age bins\n    dat <- dat %>% mutate(agebin = round(age / 2) * 2)\n    ss <- group_by(dat, agebin) %>%\n        do({\n            a <- summary(lm(y ~ g, data=.))\n            tibble(\n                agebin = .$agebin[1],\n                beta = a$coefficients[2, 1],\n                se = a$coefficients[2, 2]\n            )\n        })\n    return(ss)\n\n}\n\nplot_gxage <- function(sim) {\n    ss <- sumstats(sim$dat)\n    m2 <- rma.uni(yi=beta, sei=se, mods = ~ poly(agebin, degree=3, raw=TRUE), data=ss)\n    coefs <- tibble(\n        method=\"metareg\",\n        poly=0:3,\n        b = m2$beta[1:4],\n        se = m2$se[1:4],\n        pval = m2$pval[1:4]\n    )\n    sav <- predict(m2, newmods=unname(poly(ss$agebin, degree=3, raw=TRUE))) %>% as_tibble() %>% mutate(agebin=ss$agebin)\n    plot(pred ~ agebin, data=sav, type=\"l\")\n    lines(ci.lb ~ agebin, data=sav, type=\"l\", lty=2)\n    lines(ci.ub ~ agebin, data=sav, type=\"l\", lty=2)\n    lines(bxage ~ age, sim$coef, col=\"red\")\n    points(beta ~ agebin, data=ss, pch=16, cex=0.01/ss$se)\n    return(coefs)\n}\n\nplot_gxage(sim)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-3-1.png){width=672}\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 4 × 5\n  method   poly           b         se   pval\n  <chr>   <int>       <dbl>      <dbl>  <dbl>\n1 metareg     0  1.10       0.588      0.0618\n2 metareg     1 -0.0603     0.0331     0.0684\n3 metareg     2  0.00112    0.000612   0.0685\n4 metareg     3 -0.00000683 0.00000372 0.0667\n```\n\n\n:::\n:::\n\n\nThe red line is the true genotype x age coefficient, and the black line is the estimated effect of the genotype on the phenotype with age. Dotted lines are the confidence intervals.\n\nIn this example there is no heterogeneity in the effect of the genotype on the phenotype with age, so the confidence intervals of the polynomial fit are very wide.\n\nExample **with interaction**:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsim <- simdat(500000, 0, 0.02, 0.02, 0.02)\nplot_gxage(sim)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-4-1.png){width=672}\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 4 × 5\n  method   poly            b         se  pval\n  <chr>   <int>        <dbl>      <dbl> <dbl>\n1 metareg     0  0.0960      0.624      0.878\n2 metareg     1 -0.00273     0.0351     0.938\n3 metareg     2 -0.0000340   0.000650   0.958\n4 metareg     3  0.000000948 0.00000395 0.811\n```\n\n\n:::\n:::\n\n\nNow the confidence intervals are much narrower, and the true effect of the genotype on the phenotype with age is captured by the polynomial fit.\n\n## Performance simulations\n\nEvaluate power and type 2 error of different approaches to detect G x age interactions. Approaches using age-stratified summary statistics:\n\n- Cochran's Q statistic\n- Meta-regression with simple linear model\n- Meta-regression with polynomial terms\n\nApproaches using individual level data across all ages:\n\n- Main effect of genotype (no interaction)\n- Linear G x age interaction\n- Polynomial G x age interaction\n\n\n::: {.cell}\n\n```{.r .cell-code}\nestimation <- function(dat) {\n    ss <- sumstats(dat)\n    m1 <- rma.uni(yi=ss$beta, sei=ss$se, method=\"FE\")\n    m2 <- rma.uni(yi=beta, sei=se, mods = ~ poly(agebin, degree=3), data=ss)\n    m6 <- rma(yi=beta, sei=se, mods = ~ rcs(agebin, 4), data=ss)\n    m7 <- rma(yi=beta, sei=se, mods = ~ agebin, data=ss)\n\n    # Compare against individual level models\n    m3 <- summary(lm(y ~ g * poly(age, 3), data=dat))\n    m4 <- summary(lm(y ~ g, data=dat))\n    m5 <- summary(lm(y ~ g * age, data=dat))\n    m8 <- summary(lm(y ~ g + rcs(age, 4), data=dat))\n\n    bind_rows(\n        tibble(method=\"heterogeneity\", Q=m1$QE, pval=m1$QEp),\n        tibble(\n            method=\"meta_poly\",\n            poly=1:3,\n            b = m2$beta[2:4],\n            se = m2$se[2:4],\n            pval = m2$pval[2:4]\n        ),\n        tibble(\n            method=\"meta_rcs\",\n            poly=1:3,\n            b = m6$beta[2:4],\n            se = m6$se[2:4],\n            pval = m6$pval[2:4]\n        ),\n        tibble(\n            method=\"meta_linear\",\n            poly=1,\n            b = m7$beta[2],\n            se = m7$se[2],\n            pval = m7$pval[2]\n        ),\n        tibble(\n            method=\"ind_poly\",\n            poly=1:3,\n            b = m3$coef[5:7, 1],\n            se = m3$coef[5:7, 2],\n            pval = m3$coef[5:7, 4]\n        ),\n        tibble(\n            method=\"ind_linear\",\n            poly=1,\n            b = m5$coef[4, 1],\n            se = m5$coef[4, 2],\n            pval = m5$coef[4, 4]\n        ),\n        tibble(\n            method=\"ind_rcs\",\n            poly=1:3,\n            b = m8$coef[2:4, 1],\n            se = m8$coef[2:4, 2],\n            pval = m8$coef[2:4, 4]\n        ),\n        tibble(\n            method=\"main\",\n            b = m4$coefficients[2, 1],\n            se = m4$coefficients[2, 2],\n            pval = m4$coefficients[2, 4]\n        )\n    )\n}\n\n# Function to run whole simulation\nrun_sim <- function(b0=0, b1=0, b2=0, b3=0, n=500000, sim=1) {\n    args <- as.list(environment()) %>% as_tibble()\n    sim <- simdat(n, b0, b1, b2, b3)\n    est <- estimation(sim$dat)\n    est <- bind_cols(est, as_tibble(args))\n    return(est)\n}\n\n# Example\nrun_sim(0.02, 0, 0, 0.05)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 16 × 12\n   method       Q     pval  poly        b       se    b0    b1    b2    b3     n\n   <chr>    <dbl>    <dbl> <dbl>    <dbl>    <dbl> <dbl> <dbl> <dbl> <dbl> <dbl>\n 1 heterog…  70.1 4.21e- 9    NA NA       NA        0.02     0     0  0.05   5e5\n 2 meta_po…  NA   3.41e-13     1  0.0667   9.17e-3  0.02     0     0  0.05   5e5\n 3 meta_po…  NA   4.50e- 1     2  0.00705  9.34e-3  0.02     0     0  0.05   5e5\n 4 meta_po…  NA   5.07e- 3     3  0.0264   9.41e-3  0.02     0     0  0.05   5e5\n 5 meta_rcs  NA   8.52e- 4     1  0.00302  9.05e-4  0.02     0     0  0.05   5e5\n 6 meta_rcs  NA   2.19e- 2     2 -0.0161   7.03e-3  0.02     0     0  0.05   5e5\n 7 meta_rcs  NA   1.90e- 2     3  0.0255   1.09e-2  0.02     0     0  0.05   5e5\n 8 meta_li…  NA   2.60e-10     1  0.00169  2.67e-4  0.02     0     0  0.05   5e5\n 9 ind_poly  NA   5.07e- 1     1  1.15     1.73e+0  0.02     0     0  0.05   5e5\n10 ind_poly  NA   6.26e-13     2 10.2      1.41e+0  0.02     0     0  0.05   5e5\n11 ind_poly  NA   4.32e- 1     3  1.11     1.41e+0  0.02     0     0  0.05   5e5\n12 ind_lin…  NA   6.07e-13     1  0.00166  2.30e-4  0.02     0     0  0.05   5e5\n13 ind_rcs   NA   2.94e-21     1  0.0189   2.00e-3  0.02     0     0  0.05   5e5\n14 ind_rcs   NA   1.55e-12     2  0.00577  8.16e-4  0.02     0     0  0.05   5e5\n15 ind_rcs   NA   4.43e- 7     3 -0.0151   2.99e-3  0.02     0     0  0.05   5e5\n16 main      NA   4.22e-21    NA  0.0188   2.00e-3  0.02     0     0  0.05   5e5\n# ℹ 1 more variable: sim <dbl>\n```\n\n\n:::\n:::\n\n\nDo this over a range of scenarios (this was run on HPC in parallel)\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(furrr)\nparam <- expand.grid(\n    n = c(300000),\n    b0 = c(0, -0.02),\n    b1 = c(0, 0.02),\n    b2 = c(0, -0.02, 0.02),\n    b3 = c(0, -0.02, 0.02),\n    sim=1:200\n)\n\nplan(multicore(workers=50))\nopt <- furrr_options(seed=TRUE)\nres <- future_pmap(param, run_sim, .progress=TRUE, .options=opt) %>% bind_rows()\n\nsaveRDS(res, \"sim.rds\")\n```\n:::\n\n\n\n## Results\n\n\n::: {.cell}\n\n```{.r .cell-code}\nres <- readRDS(\"sim.rds\")\n\nress <- res %>% group_by(n, b0, b1, b2, b3, sim, method) %>%\n    summarise(minp=min(pval)) %>% ungroup()\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\n`summarise()` has grouped output by 'n', 'b0', 'b1', 'b2', 'b3', 'sim'. You can\noverride using the `.groups` argument.\n```\n\n\n:::\n:::\n\n\n\n**First check false discovery rates**\n\n\n::: {.cell}\n\n```{.r .cell-code}\nress %>% group_by(main = b0 != 0, gxage = (b1 != 0 | b2 != 0 | b3 != 0), method) %>%\n    summarise(power=mean(minp < 0.05)) %>%\n    filter(!gxage)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\n`summarise()` has grouped output by 'main', 'gxage'. You can override using the\n`.groups` argument.\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 12 × 4\n# Groups:   main, gxage [2]\n   main  gxage method        power\n   <lgl> <lgl> <chr>         <dbl>\n 1 FALSE FALSE heterogeneity 0.055\n 2 FALSE FALSE ind_linear    0.035\n 3 FALSE FALSE ind_poly      0.13 \n 4 FALSE FALSE main          0.065\n 5 FALSE FALSE meta_linear   0.03 \n 6 FALSE FALSE meta_poly     0.1  \n 7 TRUE  FALSE heterogeneity 0.06 \n 8 TRUE  FALSE ind_linear    0.035\n 9 TRUE  FALSE ind_poly      0.08 \n10 TRUE  FALSE main          1    \n11 TRUE  FALSE meta_linear   0.02 \n12 TRUE  FALSE meta_poly     0.09 \n```\n\n\n:::\n:::\n\n\nModel names:\n\n- `main` = Individual level main effect of genotype with no interaction estimation\n- `ind_linear` = Individual level G x age with linear interaction\n- `ind_poly` = Individual level G x age with polynomial interaction\n- `heterogeneity` = Cochran's Q statistic for age-stratified summary statistics\n- `meta_linear` = Meta-regression for age-stratified summary statistics using linear interaction\n- `meta_poly` = Meta-regression for age-stratified summary statistics using polynomial interaction\n\nSummary:\n\n- Heterogeneity has well controlled type 1 error when there is a main effect and when there is no main effect\n- individual level and meta regression linear models both have well controlled type 1 error when there is no interaction\n- individual level and meta regression polynomial models both have inflated type 1 error when there is no interaction (due to overfitting)\n\n**Check power**\n\n\n::: {.cell}\n\n```{.r .cell-code}\nress %>% group_by(main = b0 != 0, gxage = (b1 != 0 | b2 != 0 | b3 != 0), method) %>%\n    summarise(power=mean(minp < 0.05)) %>%\n    filter(gxage)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\n`summarise()` has grouped output by 'main', 'gxage'. You can override using the\n`.groups` argument.\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 12 × 4\n# Groups:   main, gxage [2]\n   main  gxage method        power\n   <lgl> <lgl> <chr>         <dbl>\n 1 FALSE TRUE  heterogeneity 0.615\n 2 FALSE TRUE  ind_linear    0.712\n 3 FALSE TRUE  ind_poly      0.860\n 4 FALSE TRUE  main          0.53 \n 5 FALSE TRUE  meta_linear   0.640\n 6 FALSE TRUE  meta_poly     0.835\n 7 TRUE  TRUE  heterogeneity 0.629\n 8 TRUE  TRUE  ind_linear    0.714\n 9 TRUE  TRUE  ind_poly      0.872\n10 TRUE  TRUE  main          1.00 \n11 TRUE  TRUE  meta_linear   0.643\n12 TRUE  TRUE  meta_poly     0.85 \n```\n\n\n:::\n:::\n\n\nSummary:\n\n- Detecting G x age using `heterogeneity` (Cochran's Q) is reasonably powered ut has lower power than other approaches\n- Individual models have slightly higher power than meta-regression models\n\n\n---\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsessionInfo()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nR version 4.4.1 (2024-06-14)\nPlatform: aarch64-apple-darwin20\nRunning under: macOS Sonoma 14.6.1\n\nMatrix products: default\nBLAS:   /Library/Frameworks/R.framework/Versions/4.4-arm64/Resources/lib/libRblas.0.dylib \nLAPACK: /Library/Frameworks/R.framework/Versions/4.4-arm64/Resources/lib/libRlapack.dylib;  LAPACK version 3.12.0\n\nlocale:\n[1] en_US.UTF-8/en_US.UTF-8/en_US.UTF-8/C/en_US.UTF-8/en_US.UTF-8\n\ntime zone: Europe/London\ntzcode source: internal\n\nattached base packages:\n[1] stats     graphics  grDevices utils     datasets  methods   base     \n\nother attached packages:\n[1] rms_6.8-2           Hmisc_5.2-0         metafor_4.6-0      \n[4] numDeriv_2016.8-1.1 metadat_1.2-0       Matrix_1.7-0       \n[7] dplyr_1.1.4        \n\nloaded via a namespace (and not attached):\n [1] gtable_0.3.6       xfun_0.48          ggplot2_3.5.1      htmlwidgets_1.6.4 \n [5] lattice_0.22-6     mathjaxr_1.6-0     vctrs_0.6.5        tools_4.4.1       \n [9] generics_0.1.3     sandwich_3.1-1     tibble_3.2.1       fansi_1.0.6       \n[13] cluster_2.1.6      pkgconfig_2.0.3    data.table_1.16.2  checkmate_2.3.2   \n[17] lifecycle_1.0.4    compiler_4.4.1     stringr_1.5.1      MatrixModels_0.5-3\n[21] munsell_0.5.1      codetools_0.2-20   SparseM_1.84-2     quantreg_5.99     \n[25] htmltools_0.5.8.1  yaml_2.3.10        htmlTable_2.4.3    Formula_1.2-5     \n[29] pillar_1.9.0       MASS_7.3-60.2      rpart_4.1.23       multcomp_1.4-26   \n[33] nlme_3.1-164       tidyselect_1.2.1   digest_0.6.37      polspline_1.1.25  \n[37] mvtnorm_1.2-5      stringi_1.8.4      splines_4.4.1      fastmap_1.2.0     \n[41] grid_4.4.1         colorspace_2.1-1   cli_3.6.3          magrittr_2.0.3    \n[45] base64enc_0.1-3    survival_3.6-4     utf8_1.2.4         TH.data_1.1-2     \n[49] withr_3.0.2        foreign_0.8-86     scales_1.3.0       backports_1.5.0   \n[53] rmarkdown_2.27     nnet_7.3-19        gridExtra_2.3      zoo_1.8-12        \n[57] evaluate_1.0.1     knitr_1.48         rlang_1.1.4        glue_1.8.0        \n[61] rstudioapi_0.16.0  jsonlite_1.8.9     R6_2.5.1          \n```\n\n\n:::\n:::\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}