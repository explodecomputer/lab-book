{
  "hash": "e92e11a58dcac7dd58b69c2b15bc305e",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Checking MZ difference model\"\nauthor: Gibran Hemani\ndate: \"2024-02-27\"\ncategories: []\n---\n\n\n## Background\n\n\n- Check that mean effects can't influence MZ dif effects\n- That the MZ difference model works for binary traits\n\nSimulate data\n\n- `g1` = main effect on y\n- `g2` = GxE effect with no main effect on y, with an interaction with normally distributed `f` variable\n- `g3` = Effect on variance of y\n- `g4` = Null\n- `y` - continuous variable\n- `cc` - `y` converted to a binary variable\n- `cs` - `cc` scaled to have mean 0 and variance 1\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(dplyr)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\n\nAttaching package: 'dplyr'\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nThe following objects are masked from 'package:stats':\n\n    filter, lag\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nThe following objects are masked from 'package:base':\n\n    intersect, setdiff, setequal, union\n```\n\n\n:::\n\n```{.r .cell-code}\nlibrary(ggplot2)\nlibrary(tidyr)\n\nn <- 100000\ndat <- tibble(\n    fid = rep(1:(n/2), each=2), # family id\n    id = rep(1:2, n/2),\n    g1 = rbinom(n/2, 2, 0.4) %>% rep(., each=2),\n    g2 = rbinom(n/2, 2, 0.4) %>% rep(., each=2),\n    g3 = rbinom(n/2, 2, 0.4) %>% rep(., each=2),\n    g4 = rbinom(n/2, 2, 0.4) %>% rep(., each=2),\n    f = rnorm(n),\n    v = rnorm(n, 0, g3),\n    y = 10 + g1 + f + f * drop(scale(g2)) + v + rnorm(n),\n    yr = round(y),\n    cc = rbinom(n, 1, plogis(-2 + y)),\n    cs = drop(scale(cc))\n)\ndat\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 100,000 × 12\n     fid    id    g1    g2    g3    g4      f       v     y    yr    cc     cs\n   <int> <int> <int> <int> <int> <int>  <dbl>   <dbl> <dbl> <dbl> <int>  <dbl>\n 1     1     1     0     1     2     2 -1.13   1.23   10.2     10     1 0.0485\n 2     1     2     0     1     2     2 -0.370 -4.28    5.64     6     1 0.0485\n 3     2     1     1     0     1     1  0.221 -0.974  10.0     10     1 0.0485\n 4     2     2     1     0     1     1 -1.08   0.864  12.9     13     1 0.0485\n 5     3     1     0     1     2     1  0.139  2.83   12.6     13     1 0.0485\n 6     3     2     0     1     2     1 -0.183  1.91   11.4     11     1 0.0485\n 7     4     1     0     0     1     1  0.742  0.709  10.4     10     1 0.0485\n 8     4     2     0     0     1     1 -0.223  0.865  10.1     10     1 0.0485\n 9     5     1     2     0     1     1 -0.473 -2.45   10.2     10     1 0.0485\n10     5     2     2     0     1     1  0.118  0.0939 13.7     14     1 0.0485\n# ℹ 99,990 more rows\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nmean(dat$y)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 10.80003\n```\n\n\n:::\n\n```{.r .cell-code}\nvar(dat$y)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 4.556581\n```\n\n\n:::\n:::\n\n\nCreate MZ data\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndat2 <- dat %>% \n    group_by(fid) %>% \n    summarise(\n        g1 = g1[1], \n        g2 = g2[1], \n        g3 = g3[1], \n        g4 = g4[1], \n        y2 = (y[1]+y[2])^2,\n        y = y[1]-y[2], \n        yrabs = abs(yr[1]-yr[2]), \n        yabs=abs(y), \n        cc=cc[1]-cc[2], \n        cm = mean(cc),\n        ccabs=abs(cc),\n        cs2=(cs[1]-cs[2])^2,\n        cs=cs[1]-cs[2], \n        csabs=abs(cs)\n    )\ndat2\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 50,000 × 15\n     fid    g1    g2    g3    g4    y2      y yrabs  yabs    cc    cm ccabs\n   <int> <int> <int> <int> <int> <dbl>  <dbl> <dbl> <dbl> <int> <dbl> <int>\n 1     1     0     1     2     2  252.  4.59      4 4.59      0     0     0\n 2     2     1     0     1     1  528. -2.90      3 2.90      0     0     0\n 3     3     0     1     2     1  576.  1.27      2 1.27      0     0     0\n 4     4     0     0     1     1  420.  0.396     0 0.396     0     0     0\n 5     5     2     0     1     1  574. -3.48      4 3.48      0     0     0\n 6     6     0     0     0     0  393. -0.900     1 0.900     0     0     0\n 7     7     2     1     1     1  433.  3.78      3 3.78      0     0     0\n 8     8     0     0     1     1  427. -0.790     1 0.790     0     0     0\n 9     9     1     1     1     0  412.  5.79      6 5.79      0     0     0\n10    10     0     0     1     1  299.  0.424     1 0.424     0     0     0\n# ℹ 49,990 more rows\n# ℹ 3 more variables: cs2 <dbl>, cs <dbl>, csabs <dbl>\n```\n\n\n:::\n:::\n\n\nThis creates the following potential dependent variables for the regression.\n\n- `y` which is the difference in `y` between the two MZ twins (as stated in the equation in the paper)\n- `yabs` which is the absolute difference in `y` between the two MZ twins\n- `cc` which is the difference in `cc` between the two MZ twins\n- `ccabs` which is the absolute difference in `cc` between the two MZ twins\n- `cs` which is the difference in the scaled binary variable between the two MZ twins\n- `cs2` which is the squared difference in the scaled binary variable between the two MZ twins\n\n`cm` is also generated - the mean of `cc` for the MZ twins. This is the covariate used in model 2 according to the methods in the paper.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nreg <- function(f, dat, what) {\n    fo <- as.formula(f)\n    o <- lm(fo, data=dat) %>% summary() %>% \n        coef() %>% \n        as.data.frame() %>%\n        slice_tail(n=1) %>%\n        mutate(what=what, f=f)\n    rownames(o) <- NULL\n    names(o) <- c(\"est\", \"se\", \"t\", \"p\", \"what\", \"f\")\n    o %>% select(what, f, est, se, p)\n}\n\no <- bind_rows(\n    reg(\"cc ~ g1\", dat, \"pop\"),\n    reg(\"cc ~ g2\", dat, \"pop\"),\n    reg(\"cc ~ g3\", dat, \"pop\"),\n    reg(\"cc ~ g4\", dat, \"pop\"),\n    reg(\"y ~ g1\", dat2, \"mz\"),\n    reg(\"y ~ g2\", dat2, \"mz\"),\n    reg(\"y ~ g3\", dat2, \"mz\"),\n    reg(\"y ~ g4\", dat2, \"mz\"),\n    reg(\"yabs ~ g1\", dat2, \"mz\"),\n    reg(\"yabs ~ g2\", dat2, \"mz\"),\n    reg(\"yabs ~ g3\", dat2, \"mz\"),\n    reg(\"yabs ~ g4\", dat2, \"mz\"),\n    reg(\"yrabs ~ g1\", dat2, \"mz\"),\n    reg(\"yrabs ~ g2\", dat2, \"mz\"),\n    reg(\"yrabs ~ g3\", dat2, \"mz\"),\n    reg(\"yrabs ~ g4\", dat2, \"mz\"),\n    reg(\"yabs ~ g1 + cm\", dat2, \"mz\"),\n    reg(\"yabs ~ g2 + cm\", dat2, \"mz\"),\n    reg(\"yabs ~ g3 + cm\", dat2, \"mz\"),\n    reg(\"yabs ~ g4 + cm\", dat2, \"mz\"),\n    reg(\"cc ~ g1\", dat2, \"mz\"),\n    reg(\"cc ~ g2\", dat2, \"mz\"),\n    reg(\"cc ~ g3\", dat2, \"mz\"),\n    reg(\"cc ~ g4\", dat2, \"mz\"),\n    reg(\"ccabs ~ g1\", dat2, \"mz\"),\n    reg(\"ccabs ~ g2\", dat2, \"mz\"),\n    reg(\"ccabs ~ g3\", dat2, \"mz\"),\n    reg(\"ccabs ~ g4\", dat2, \"mz\"),\n    reg(\"cs ~ g1\", dat2, \"mz\"),\n    reg(\"cs ~ g2\", dat2, \"mz\"),\n    reg(\"cs ~ g3\", dat2, \"mz\"),\n    reg(\"cs ~ g4\", dat2, \"mz\"),\n    reg(\"csabs ~ g1\", dat2, \"mz\"),\n    reg(\"csabs ~ g2\", dat2, \"mz\"),\n    reg(\"csabs ~ g3\", dat2, \"mz\"),\n    reg(\"csabs ~ g4\", dat2, \"mz\"),\n    reg(\"cs2 ~ g1\", dat2, \"mz\"),\n    reg(\"cs2 ~ g2\", dat2, \"mz\"),\n    reg(\"cs2 ~ g3\", dat2, \"mz\"),\n    reg(\"cs2 ~ g4\", dat2, \"mz\"),\n    reg(\"ccabs ~ g1 + cm\", dat2, \"mz\"),\n    reg(\"ccabs ~ g2 + cm\", dat2, \"mz\"),\n    reg(\"ccabs ~ g3 + cm\", dat2, \"mz\"),\n    reg(\"ccabs ~ g4 + cm\", dat2, \"mz\")\n)\no %>% mutate(log10p=-log10(p)) %>% select(what, f, log10p)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   what               f      log10p\n1   pop         cc ~ g1  8.13437917\n2   pop         cc ~ g2 46.55305857\n3   pop         cc ~ g3 13.91572848\n4   pop         cc ~ g4  0.19781815\n5    mz          y ~ g1  0.19778963\n6    mz          y ~ g2  1.16427524\n7    mz          y ~ g3  1.13649518\n8    mz          y ~ g4  0.15581555\n9    mz       yabs ~ g1  0.06830983\n10   mz       yabs ~ g2         Inf\n11   mz       yabs ~ g3         Inf\n12   mz       yabs ~ g4  1.78854106\n13   mz      yrabs ~ g1  0.18522135\n14   mz      yrabs ~ g2         Inf\n15   mz      yrabs ~ g3         Inf\n16   mz      yrabs ~ g4  1.67808693\n17   mz  yabs ~ g1 + cm  3.47796265\n18   mz  yabs ~ g2 + cm  2.75990563\n19   mz  yabs ~ g3 + cm  3.54724083\n20   mz  yabs ~ g4 + cm  3.48276126\n21   mz         cc ~ g1  0.01511599\n22   mz         cc ~ g2  1.26990270\n23   mz         cc ~ g3  0.05031756\n24   mz         cc ~ g4  0.09356251\n25   mz      ccabs ~ g1  8.15308162\n26   mz      ccabs ~ g2 46.70726528\n27   mz      ccabs ~ g3 13.95034699\n28   mz      ccabs ~ g4  0.19808941\n29   mz         cs ~ g1  0.01511599\n30   mz         cs ~ g2  1.26990270\n31   mz         cs ~ g3  0.05031756\n32   mz         cs ~ g4  0.09356251\n33   mz      csabs ~ g1  8.15308162\n34   mz      csabs ~ g2 46.70726528\n35   mz      csabs ~ g3 13.95034699\n36   mz      csabs ~ g4  0.19808941\n37   mz        cs2 ~ g1  8.15308162\n38   mz        cs2 ~ g2 46.70726528\n39   mz        cs2 ~ g3 13.95034699\n40   mz        cs2 ~ g4  0.19808941\n41   mz ccabs ~ g1 + cm 58.05048015\n42   mz ccabs ~ g2 + cm 57.36591496\n43   mz ccabs ~ g3 + cm 58.03887907\n44   mz ccabs ~ g4 + cm 58.00836961\n```\n\n\n:::\n:::\n\n\nObservations\n\n- The MZ difference model does not work for the difference of `y`\n- The MZ difference model works for continuous traits as expected when using the **absolute** difference in the trait (`yabs`). i.e.\n    - The main effect does not associate with MZ dif\n    - The GxE effect does associate with MZ dif\n    - The variance effect does associate with MZ dif\n- The MZ difference model does not work for the difference of the binary trait `cc`\n- Using the absolute difference in the binary trait (`ccabs`)\n    - Picks up the GxE effect and the variance effect\n    - **But it also picks up the main effect which it is not supposed to do**\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nreg2 <- function(f, dat, what) {\n    fo <- as.formula(f)\n    o <- glm(fo, data=dat, family=\"binomial\") %>% summary() %>% \n        coef() %>% \n        as.data.frame() %>%\n        slice_tail(n=1) %>%\n        mutate(what=what, f=f)\n    rownames(o) <- NULL\n    names(o) <- c(\"est\", \"se\", \"t\", \"p\", \"what\", \"f\")\n    o %>% select(what, f, est, se, p)\n}\no <- bind_rows(\n    reg2(\"ccabs ~ g1\", dat2, \"mz\"),\n    reg2(\"ccabs ~ g2\", dat2, \"mz\"),\n    reg2(\"ccabs ~ g3\", dat2, \"mz\"),\n    reg2(\"ccabs ~ g4\", dat2, \"mz\"),\n    reg2(\"ccabs ~ g1 + cm\", dat2, \"mz\"),\n    reg2(\"ccabs ~ g2 + cm\", dat2, \"mz\"),\n    reg2(\"ccabs ~ g3 + cm\", dat2, \"mz\"),\n    reg2(\"ccabs ~ g4 + cm\", dat2, \"mz\")\n)\no %>% select(what, f, p) %>% mutate(p=-log10(p))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  what               f         p\n1   mz      ccabs ~ g1  7.935807\n2   mz      ccabs ~ g2 40.034814\n3   mz      ccabs ~ g3 13.406643\n4   mz      ccabs ~ g4  0.198076\n5   mz ccabs ~ g1 + cm 36.633562\n6   mz ccabs ~ g2 + cm 24.068483\n7   mz ccabs ~ g3 + cm 34.455607\n8   mz ccabs ~ g4 + cm 39.375746\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nsummary(lm(y ~ f * g2, dat))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\nCall:\nlm(formula = y ~ f * g2, data = dat)\n\nResiduals:\n    Min      1Q  Median      3Q     Max \n-9.4461 -1.0290 -0.0064  1.0158  8.9290 \n\nCoefficients:\n             Estimate Std. Error  t value Pr(>|t|)    \n(Intercept) 10.793645   0.007749 1392.938   <2e-16 ***\nf           -0.143231   0.007751  -18.479   <2e-16 ***\ng2           0.006294   0.007347    0.857    0.392    \nf:g2         1.437658   0.007385  194.679   <2e-16 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nResidual standard error: 1.608 on 99996 degrees of freedom\nMultiple R-squared:  0.4322,\tAdjusted R-squared:  0.4322 \nF-statistic: 2.537e+04 on 3 and 99996 DF,  p-value: < 2.2e-16\n```\n\n\n:::\n\n```{.r .cell-code}\ntapply(dat$y, dat$g2, var)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n       0        1        2 \n2.592929 4.284458 9.876482 \n```\n\n\n:::\n\n```{.r .cell-code}\ntapply(dat$y, dat$g3, var)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n       0        1        2 \n3.496772 4.400120 7.443893 \n```\n\n\n:::\n\n```{.r .cell-code}\ntapply(dat2$yabs, dat2$g2, mean)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n       0        1        2 \n1.575618 2.178511 3.482465 \n```\n\n\n:::\n\n```{.r .cell-code}\ntapply(dat2$yabs, dat2$g3, mean)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n       0        1        2 \n1.821039 2.166061 2.954501 \n```\n\n\n:::\n:::\n\n\n\n## Trait skewness\n\n\n::: {.cell}\n\n```{.r .cell-code}\nn <- 100000\ndat <- tibble(\n    fid = rep(1:(n/2), each=2), # family id\n    id = rep(1:2, n/2),\n    g1 = rbinom(n/2, 2, 0.4) %>% rep(., each=2),\n    g2 = rbinom(n/2, 2, 0.4) %>% rep(., each=2),\n    g3 = rbinom(n/2, 2, 0.4) %>% rep(., each=2),\n    g4 = rbinom(n/2, 2, 0.4) %>% rep(., each=2),\n    f = rnorm(n),\n    v = rnorm(n, 0, g3),\n    y = (10 + g1 + f + f * drop(scale(g2)) + v + rnorm(n))^1.2,\n    yr = round(y),\n    cc = rbinom(n, 1, plogis(-2 + y)),\n    cs = drop(scale(cc))\n)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning in rbinom(n, 1, plogis(-2 + y)): NAs produced\n```\n\n\n:::\n\n```{.r .cell-code}\ndat\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 100,000 × 12\n     fid    id    g1    g2    g3    g4       f      v     y    yr    cc     cs\n   <int> <int> <int> <int> <int> <int>   <dbl>  <dbl> <dbl> <dbl> <int>  <dbl>\n 1     1     1     1     1     2     1 -0.412  -2.83   9.43     9     1 0.0288\n 2     1     2     1     1     2     1 -1.16    1.39  17.7     18     1 0.0288\n 3     2     1     0     0     2     0  0.454   0.786 18.5     19     1 0.0288\n 4     2     2     0     0     2     0 -0.0107  1.83  16.9     17     1 0.0288\n 5     3     1     1     0     1     0 -1.62    1.27  19.8     20     1 0.0288\n 6     3     2     1     0     1     0 -0.644   0.552 19.8     20     1 0.0288\n 7     4     1     2     0     0     0 -0.231   0     24.2     24     1 0.0288\n 8     4     2     2     0     0     0 -0.132   0     21.0     21     1 0.0288\n 9     5     1     0     2     0     1  0.893   0     21.3     21     1 0.0288\n10     5     2     0     2     0     1  2.10    0     24.5     25     1 0.0288\n# ℹ 99,990 more rows\n```\n\n\n:::\n:::\n\n\nCreate MZ data\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndat2 <- dat %>% \n    group_by(fid) %>% \n    summarise(\n        g1 = g1[1], \n        g2 = g2[1], \n        g3 = g3[1], \n        g4 = g4[1], \n        y2 = (y[1]+y[2])^2,\n        ym = mean(c(y[1], y[2])),\n        y = y[1]-y[2], \n        yrabs = abs(yr[1]-yr[2]), \n        yabs=abs(y), \n        cc=cc[1]-cc[2], \n        cm = mean(cc),\n        ccabs=abs(cc),\n        cs2=(cs[1]-cs[2])^2,\n        cs=cs[1]-cs[2], \n        csabs=abs(cs)\n    )\ndat2\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 50,000 × 16\n     fid    g1    g2    g3    g4    y2    ym       y yrabs   yabs    cc    cm\n   <int> <int> <int> <int> <int> <dbl> <dbl>   <dbl> <dbl>  <dbl> <int> <dbl>\n 1     1     1     1     2     1  738.  13.6 -8.31       9 8.31       0     0\n 2     2     0     0     2     0 1255.  17.7  1.61       2 1.61       0     0\n 3     3     1     0     1     0 1569.  19.8 -0.0223     0 0.0223     0     0\n 4     4     2     0     0     0 2044.  22.6  3.16       3 3.16       0     0\n 5     5     0     2     0     1 2099.  22.9 -3.26       4 3.26       0     0\n 6     6     1     1     2     2  863.  14.7 -4.19       4 4.19       0     0\n 7     7     1     1     2     1 1286.  17.9  4.58       4 4.58       0     0\n 8     8     2     1     0     2 1852.  21.5  0.751      1 0.751      0     0\n 9     9     0     1     1     1 1293.  18.0 -1.99       2 1.99       0     0\n10    10     0     0     1     0  753.  13.7  5.84       6 5.84       0     0\n# ℹ 49,990 more rows\n# ℹ 4 more variables: ccabs <int>, cs2 <dbl>, cs <dbl>, csabs <dbl>\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\no <- bind_rows(\n    reg(\"y ~ g1\", dat, \"pop\"),\n    reg(\"y ~ g2\", dat, \"pop\"),\n    reg(\"y ~ g3\", dat, \"pop\"),\n    reg(\"y ~ g4\", dat, \"pop\"),\n    reg(\"y ~ g1\", dat2, \"mz\"),\n    reg(\"y ~ g2\", dat2, \"mz\"),\n    reg(\"y ~ g3\", dat2, \"mz\"),\n    reg(\"y ~ g4\", dat2, \"mz\"),\n    reg(\"yabs ~ g1\", dat2, \"mz\"),\n    reg(\"yabs ~ g2\", dat2, \"mz\"),\n    reg(\"yabs ~ g3\", dat2, \"mz\"),\n    reg(\"yabs ~ g4\", dat2, \"mz\"),\n    reg(\"yrabs ~ g1\", dat2, \"mz\"),\n    reg(\"yrabs ~ g2\", dat2, \"mz\"),\n    reg(\"yrabs ~ g3\", dat2, \"mz\"),\n    reg(\"yrabs ~ g4\", dat2, \"mz\"),\n    reg(\"yabs ~ g1 + cm\", dat2, \"mz\"),\n    reg(\"yabs ~ g2 + cm\", dat2, \"mz\"),\n    reg(\"yabs ~ g3 + cm\", dat2, \"mz\"),\n    reg(\"yabs ~ g4 + cm\", dat2, \"mz\")\n)\no %>% mutate(log10p=-log10(p)) %>% select(what, f, log10p)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   what              f     log10p\n1   pop         y ~ g1        Inf\n2   pop         y ~ g2 3.54935291\n3   pop         y ~ g3 2.46395634\n4   pop         y ~ g4 0.09327347\n5    mz         y ~ g1 0.08682220\n6    mz         y ~ g2 0.47730024\n7    mz         y ~ g3 0.50247418\n8    mz         y ~ g4 1.00155797\n9    mz      yabs ~ g1 4.49253297\n10   mz      yabs ~ g2        Inf\n11   mz      yabs ~ g3        Inf\n12   mz      yabs ~ g4 0.01097967\n13   mz     yrabs ~ g1 4.38832450\n14   mz     yrabs ~ g2        Inf\n15   mz     yrabs ~ g3        Inf\n16   mz     yrabs ~ g4 0.01287839\n17   mz yabs ~ g1 + cm 1.23300446\n18   mz yabs ~ g2 + cm 1.29310112\n19   mz yabs ~ g3 + cm 1.67100047\n20   mz yabs ~ g4 + cm 1.21988939\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ncor(dat2$ym, dat2$y, use=\"pair\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] -0.003965853\n```\n\n\n:::\n:::\n\n\n\nMake a Poisson model and then normalise\n\n\n::: {.cell}\n\n```{.r .cell-code}\ninormal <- function(x) {\n    x <- x + rnorm(length(x), 0, 1e-10)\n    qnorm((rank(x, na.last = \"keep\") - 0.5) / sum(!is.na(x)))\n}\n\nn <- 100000\ndat <- tibble(\n    fid = rep(1:(n/2), each=2), # family id\n    id = rep(1:2, n/2),\n    g1 = rbinom(n/2, 2, 0.4) %>% rep(., each=2),\n    g2 = rbinom(n/2, 2, 0.4) %>% rep(., each=2),\n    g3 = rbinom(n/2, 2, 0.4) %>% rep(., each=2),\n    g4 = rbinom(n/2, 2, 0.4) %>% rep(., each=2),\n    f = rnorm(n),\n    e = rnorm(n),\n    v = rnorm(n, 0, g3 * 0.1),\n    y = drop(scale(g1) * 0.1 + f * 0.1 + f * drop(scale(g2)) * 0.1 + v + e),\n    l = drop(exp(scale(y) * 0.1)),\n    score = rpois(n, l),\n    score_norm = inormal(score),\n    l_norm = inormal(l)\n)\ndat\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 100,000 × 14\n     fid    id    g1    g2    g3    g4        f       e        v       y     l\n   <int> <int> <int> <int> <int> <int>    <dbl>   <dbl>    <dbl>   <dbl> <dbl>\n 1     1     1     2     0     1     0  0.787    0.546  -0.00113  0.706  1.07 \n 2     1     2     2     0     1     0  0.760    1.53   -0.0487   1.64   1.17 \n 3     2     1     0     1     1     0  1.28     0.0259 -0.00291  0.0722 1.01 \n 4     2     2     0     1     1     0  0.226    0.315  -0.128    0.101  1.01 \n 5     3     1     1     1     1     0 -0.377   -0.383   0.186   -0.217  0.979\n 6     3     2     1     1     1     0  0.901    0.751  -0.147    0.749  1.08 \n 7     4     1     0     0     0     2 -0.571    0.201   0        0.0945 1.01 \n 8     4     2     0     0     0     2 -0.00699  0.663   0        0.548  1.06 \n 9     5     1     2     0     1     0 -0.702   -0.396  -0.183   -0.395  0.962\n10     5     2     2     0     1     0 -0.351    0.738   0.176    1.09   1.11 \n# ℹ 99,990 more rows\n# ℹ 3 more variables: score <int>, score_norm <dbl>, l_norm <dbl>\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nhist(dat$score)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-12-1.png){width=672}\n:::\n\n```{.r .cell-code}\nhist(dat$score_norm)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-12-2.png){width=672}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ncor(dat$score, dat$score_norm, use=\"pair\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.9132064\n```\n\n\n:::\n\n```{.r .cell-code}\ncor(dat$score, dat$l)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.09932395\n```\n\n\n:::\n\n```{.r .cell-code}\ncor(dat$y, dat$l)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.9974787\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nmean(dat$y)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] -0.0005732355\n```\n\n\n:::\n\n```{.r .cell-code}\nvar(dat$l)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.01016003\n```\n\n\n:::\n\n```{.r .cell-code}\nmean(dat$l)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1.005014\n```\n\n\n:::\n:::\n\n\nCreate MZ data\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndat2 <- dat %>% \n    group_by(fid) %>% \n    summarise(\n        g1 = g1[1], \n        g2 = g2[1], \n        g3 = g3[1], \n        g4 = g4[1], \n        y2 = (y[1]+y[2])^2,\n        y = y[1]-y[2], \n        l = abs(l[1]-l[2]), \n        l_norm = abs(l_norm[1]-l_norm[2]),\n        yabs = abs(y), \n        score = abs(score[1]-score[2]), \n        ms = mean(score_norm),\n        score_norm = abs(score_norm[1]-score_norm[2])\n    )\ndat2\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 50,000 × 13\n     fid    g1    g2    g3    g4     y2       y       l l_norm   yabs score\n   <int> <int> <int> <int> <int>  <dbl>   <dbl>   <dbl>  <dbl>  <dbl> <int>\n 1     1     2     0     1     0 5.51   -0.936  0.103   0.908  0.936      0\n 2     2     0     1     1     0 0.0298 -0.0284 0.00281 0.0278 0.0284     2\n 3     3     1     1     1     0 0.284  -0.966  0.0972  0.948  0.966      2\n 4     4     0     0     0     2 0.413  -0.454  0.0459  0.443  0.454      1\n 5     5     2     0     1     0 0.486  -1.49   0.151   1.46   1.49       2\n 6     6     1     1     0     1 0.0765  1.31   0.130   1.29   1.31       3\n 7     7     1     1     0     1 0.297   0.830  0.0792  0.820  0.830      1\n 8     8     1     0     1     0 0.162  -1.65   0.159   1.62   1.65       0\n 9     9     1     0     1     2 0.186  -0.880  0.0880  0.864  0.880      3\n10    10     1     2     0     0 1.01   -0.759  0.0708  0.748  0.759      1\n# ℹ 49,990 more rows\n# ℹ 2 more variables: ms <dbl>, score_norm <dbl>\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nhist(dat2$l)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-16-1.png){width=672}\n:::\n\n```{.r .cell-code}\nhist(dat2$y, breaks=100)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-16-2.png){width=672}\n:::\n\n```{.r .cell-code}\nhist(dat2$score)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-16-3.png){width=672}\n:::\n\n```{.r .cell-code}\nhist(dat2$ms)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-16-4.png){width=672}\n:::\n\n```{.r .cell-code}\nhist(dat2$score_norm, breaks=100)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-16-5.png){width=672}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\no <- bind_rows(\n    reg(\"y ~ g1\", dat, \"pop\"),\n    reg(\"y ~ g2\", dat, \"pop\"),\n    reg(\"y ~ g3\", dat, \"pop\"),\n    reg(\"y ~ g4\", dat, \"pop\"),\n    reg(\"y ~ g1\", dat2, \"mz\"),\n    reg(\"y ~ g2\", dat2, \"mz\"),\n    reg(\"y ~ g3\", dat2, \"mz\"),\n    reg(\"y ~ g4\", dat2, \"mz\"),\n    reg(\"yabs ~ g1\", dat2, \"mz\"),\n    reg(\"yabs ~ g2\", dat2, \"mz\"),\n    reg(\"yabs ~ g3\", dat2, \"mz\"),\n    reg(\"yabs ~ g4\", dat2, \"mz\"),\n    reg(\"l ~ g1\", dat2, \"mz\"),\n    reg(\"l ~ g2\", dat2, \"mz\"),\n    reg(\"l ~ g3\", dat2, \"mz\"),\n    reg(\"l ~ g4\", dat2, \"mz\"),\n    reg(\"l_norm ~ g1\", dat2, \"mz\"),\n    reg(\"l_norm ~ g2\", dat2, \"mz\"),\n    reg(\"l_norm ~ g3\", dat2, \"mz\"),\n    reg(\"l_norm ~ g4\", dat2, \"mz\"),\n    reg(\"score ~ g1\", dat2, \"mz\"),\n    reg(\"score ~ g2\", dat2, \"mz\"),\n    reg(\"score ~ g3\", dat2, \"mz\"),\n    reg(\"score ~ g4\", dat2, \"mz\"),\n    reg(\"score_norm ~ g1\", dat2, \"mz\"),\n    reg(\"score_norm ~ g2\", dat2, \"mz\"),\n    reg(\"score_norm ~ g3\", dat2, \"mz\"),\n    reg(\"score_norm ~ g4\", dat2, \"mz\")\n)\no %>% mutate(log10p=-log10(p)) %>% select(what, f, log10p)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   what               f       log10p\n1   pop          y ~ g1 185.00457990\n2   pop          y ~ g2   0.20095133\n3   pop          y ~ g3   0.17362325\n4   pop          y ~ g4   0.20554817\n5    mz          y ~ g1   0.13158235\n6    mz          y ~ g2   0.24689088\n7    mz          y ~ g3   0.45566062\n8    mz          y ~ g4   0.03952470\n9    mz       yabs ~ g1   0.22962289\n10   mz       yabs ~ g2   2.48769494\n11   mz       yabs ~ g3   1.70005152\n12   mz       yabs ~ g4   0.04494941\n13   mz          l ~ g1   1.68682175\n14   mz          l ~ g2   2.51802045\n15   mz          l ~ g3   1.89948460\n16   mz          l ~ g4   0.08356243\n17   mz     l_norm ~ g1   0.26688992\n18   mz     l_norm ~ g2   2.45928566\n19   mz     l_norm ~ g3   1.68042327\n20   mz     l_norm ~ g4   0.04571569\n21   mz      score ~ g1   1.50969397\n22   mz      score ~ g2   1.50141433\n23   mz      score ~ g3   0.03509046\n24   mz      score ~ g4   0.46788282\n25   mz score_norm ~ g1   2.05042353\n26   mz score_norm ~ g2   1.52024181\n27   mz score_norm ~ g3   0.39472418\n28   mz score_norm ~ g4   0.32905683\n```\n\n\n:::\n:::\n\n\n\n## Run simulations with more replications\n\nThe general model\n\n- `y` is a continuous variable which relates to the underlying normal liability\n- `ysq` is the square of `y`, to introduce skewness\n- `ysq_norm` is the inverse rank transformed `ysq` to try to rescue the skewness\n- `l` is the exponentiated liability which will eventually give rise to the Poisson distributed variable\n- `l_norm` is the inverse rank transformed `l` to try to rescue the skewness\n- `score` is the Poisson distributed variable arising from the underlying normal liability. This aims to represent the depression / anxiety distributions\n- `score_norm` is the inverse rank transformed `score` to try to rescue the skewness. Note that small amounts of noise are introduced to avoid ties\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndgm <- function(n, b1, b2, b3, b4, bf, bf2) {\n    dat <- tibble(\n        fid = rep(1:(n/2), each=2), # family id\n        id = rep(1:2, n/2),\n        g1 = rbinom(n/2, 2, 0.4) %>% rep(., each=2),\n        g2 = rbinom(n/2, 2, 0.4) %>% rep(., each=2),\n        g3 = rbinom(n/2, 2, 0.4) %>% rep(., each=2),\n        g4 = rbinom(n/2, 2, 0.4) %>% rep(., each=2),\n        f = rnorm(n),\n        e = rnorm(n),\n        v = rnorm(n, 0, g3 * b3),\n        y = drop(scale(g1) * b1 + scale(g2) * b2 + f * bf + f * drop(scale(g2)) * bf2 + v + e + scale(g4) * b4),\n        ysq = y^2,\n        ysq_norm = inormal(ysq),\n        l = drop(exp(scale(y) * 0.1)),\n        l_norm = inormal(l),\n        score = rpois(n, l),\n        score_norm = inormal(score)\n    )\n\n    dat2 <- dat %>% \n        group_by(fid) %>% \n        summarise(\n            g1 = g1[1], \n            g2 = g2[1], \n            g3 = g3[1], \n            g4 = g4[1], \n            yraw = y[1]-y[2], \n            y = abs(yraw), \n            ysq = abs(ysq[1]+ysq[2]),\n            ysq_norm = abs(ysq_norm[1]+ysq_norm[2]),\n            l = abs(l[1]-l[2]), \n            l_norm = abs(l_norm[1]-l_norm[2]),\n            score = abs(score[1]-score[2]), \n            score_norm = abs(score_norm[1]-score_norm[2])\n        )\n    return(list(dat=dat, dat2=dat2))\n}\n\nest <- function(out) {\n    dat <- out$dat\n    dat2 <- out$dat2\n    o <- bind_rows(\n        reg(\"y ~ g1\", dat, \"pop\"),\n        reg(\"y ~ g2\", dat, \"pop\"),\n        reg(\"y ~ g3\", dat, \"pop\"),\n        reg(\"y ~ g4\", dat, \"pop\"),\n        reg(\"yraw ~ g1\", dat2, \"mz\"),\n        reg(\"yraw ~ g2\", dat2, \"mz\"),\n        reg(\"yraw ~ g3\", dat2, \"mz\"),\n        reg(\"yraw ~ g4\", dat2, \"mz\"),\n        reg(\"y ~ g1\", dat2, \"mz\"),\n        reg(\"y ~ g2\", dat2, \"mz\"),\n        reg(\"y ~ g3\", dat2, \"mz\"),\n        reg(\"y ~ g4\", dat2, \"mz\"),\n        reg(\"ysq ~ g1\", dat2, \"mz\"),\n        reg(\"ysq ~ g2\", dat2, \"mz\"),\n        reg(\"ysq ~ g3\", dat2, \"mz\"),\n        reg(\"ysq ~ g4\", dat2, \"mz\"),\n        reg(\"ysq_norm ~ g1\", dat2, \"mz\"),\n        reg(\"ysq_norm ~ g2\", dat2, \"mz\"),\n        reg(\"ysq_norm ~ g3\", dat2, \"mz\"),\n        reg(\"ysq_norm ~ g4\", dat2, \"mz\"),\n        reg(\"l ~ g1\", dat2, \"mz\"),\n        reg(\"l ~ g2\", dat2, \"mz\"),\n        reg(\"l ~ g3\", dat2, \"mz\"),\n        reg(\"l ~ g4\", dat2, \"mz\"),\n        reg(\"l_norm ~ g1\", dat2, \"mz\"),\n        reg(\"l_norm ~ g2\", dat2, \"mz\"),\n        reg(\"l_norm ~ g3\", dat2, \"mz\"),\n        reg(\"l_norm ~ g4\", dat2, \"mz\"),\n        reg(\"score ~ g1\", dat2, \"mz\"),\n        reg(\"score ~ g2\", dat2, \"mz\"),\n        reg(\"score ~ g3\", dat2, \"mz\"),\n        reg(\"score ~ g4\", dat2, \"mz\"),\n        reg(\"score_norm ~ g1\", dat2, \"mz\"),\n        reg(\"score_norm ~ g2\", dat2, \"mz\"),\n        reg(\"score_norm ~ g3\", dat2, \"mz\"),\n        reg(\"score_norm ~ g4\", dat2, \"mz\")\n    )\n    return(o)\n}\n```\n:::\n\n\nRun the sims\n\n\n::: {.cell}\n\n```{.r .cell-code}\nres <- lapply(1:100, \\(i) {\n    out <- dgm(10000, 0.3, 0, 0.3, 0, 0.3, 0.3)\n    est(out) %>% mutate(i=i)\n}) %>% bind_rows()\n```\n:::\n\n\nRe-label\n\n\n::: {.cell}\n\n```{.r .cell-code}\nres <- res %>% separate(f, c(\"trait\", \"g\"), sep=\" ~ \", remove=FALSE)\nres$g[res$g == \"g1\"] <- \"Main\"\nres$g[res$g == \"g2\"] <- \"GxE\"\nres$g[res$g == \"g3\"] <- \"Var\"\nres$g[res$g == \"g4\"] <- \"Null\"\n\nres$trait[res$trait == \"yraw\"] <- \"yraw\"\nres$trait[res$trait == \"y\"] <- \"Normal liability\"\nres$trait[res$trait == \"ysq\"] <- \"Normal liability squared\"\nres$trait[res$trait == \"ysq_norm\"] <- \"Normal liability squared (INT)\"\nres$trait[res$trait == \"l\"] <- \"Exponentiated liability\"\nres$trait[res$trait == \"l_norm\"] <- \"Exponentiated liability (INT)\"\nres$trait[res$trait == \"score\"] <- \"Poisson of liability\"\nres$trait[res$trait == \"score_norm\"] <- \"Poisson of liability (INT)\"\n```\n:::\n\n\nEvaluate performance of variance estimates on power and bias. Expect that `Main` and `Null` should be null in the MZ difference model, and `GxE` and `Var` should be non-null.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(res %>% filter(what ==\"mz\" & trait != \"yraw\") %>% group_by(trait) %>% mutate(est = est/max(est)), aes(x=g, y=est)) + \n    geom_boxplot(aes(fill=g)) +\n    theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5), legend.position=\"none\") +\n    scale_fill_brewer(palette=\"Set3\") +\n    geom_hline(yintercept=0, linetype=\"dashed\") +\n    facet_grid(. ~ trait, scale=\"free_y\", labeller = label_wrap_gen()) +\n    labs(y = \"Relative effect size\", x=\"\", fill=\"\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-21-1.png){width=672}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nggsave(file=\"mz_diff.pdf\", width=10, height=8)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(res %>% filter(what ==\"mz\" & trait != \"yraw\"), aes(x=trait, y=-log10(p))) + \n    geom_boxplot(aes(fill=g)) +\n    theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5)) +\n    scale_fill_brewer(palette=\"Set3\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-23-1.png){width=672}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nres %>% group_by(what, f, g, trait) %>% summarise(power = sum(p < 0.05)) %>%\n    ungroup %>%\n    {\n    ggplot(., aes(x=g, y=power)) + \n        geom_bar(stat=\"identity\", aes(fill=g), position=\"dodge\") +\n        theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5)) +\n        scale_fill_brewer(palette=\"Set3\") +\n        facet_grid(. ~ trait)\n    }\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\n`summarise()` has grouped output by 'what', 'f', 'g'. You can override using\nthe `.groups` argument.\n```\n\n\n:::\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-24-1.png){width=672}\n:::\n:::\n\n\n\n## Summary\n\n- Inverse rank transformation of most traits rescues the MZ difference model\n- Inverse rank transformation of the Poisson variable does not seem to work - it erases the variance effects and there is some bias remaining for the main effect\n\n\n---\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsessionInfo()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nR version 4.3.3 (2024-02-29)\nPlatform: aarch64-apple-darwin20 (64-bit)\nRunning under: macOS Ventura 13.6\n\nMatrix products: default\nBLAS:   /Library/Frameworks/R.framework/Versions/4.3-arm64/Resources/lib/libRblas.0.dylib \nLAPACK: /Library/Frameworks/R.framework/Versions/4.3-arm64/Resources/lib/libRlapack.dylib;  LAPACK version 3.11.0\n\nlocale:\n[1] en_GB.UTF-8/en_GB.UTF-8/en_GB.UTF-8/C/en_GB.UTF-8/en_GB.UTF-8\n\ntime zone: Europe/London\ntzcode source: internal\n\nattached base packages:\n[1] stats     graphics  grDevices utils     datasets  methods   base     \n\nother attached packages:\n[1] tidyr_1.3.0   ggplot2_3.4.2 dplyr_1.1.4  \n\nloaded via a namespace (and not attached):\n [1] vctrs_0.6.5        cli_3.6.2          knitr_1.45         rlang_1.1.3       \n [5] xfun_0.42          purrr_1.0.2        generics_0.1.3     textshaping_0.3.7 \n [9] jsonlite_1.8.8     labeling_0.4.2     glue_1.7.0         colorspace_2.1-0  \n[13] htmltools_0.5.7    ragg_1.2.6         scales_1.2.1       fansi_1.0.6       \n[17] rmarkdown_2.26     grid_4.3.3         munsell_0.5.0      evaluate_0.23     \n[21] tibble_3.2.1       fastmap_1.1.1      yaml_2.3.8         lifecycle_1.0.4   \n[25] compiler_4.3.3     RColorBrewer_1.1-3 htmlwidgets_1.6.3  pkgconfig_2.0.3   \n[29] systemfonts_1.0.5  farver_2.1.1       digest_0.6.34      R6_2.5.1          \n[33] tidyselect_1.2.0   utf8_1.2.4         pillar_1.9.0       magrittr_2.0.3    \n[37] withr_3.0.0        tools_4.3.3        gtable_0.3.3      \n```\n\n\n:::\n:::\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}