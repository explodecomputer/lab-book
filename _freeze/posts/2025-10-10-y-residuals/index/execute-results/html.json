{
  "hash": "e5cc5125f93b251775738d6f1ab4382d",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Residuals for PRS to overcome issue of non-independence\"\nauthor: Gibran Hemani\ndate: \"2025-10-10\"\ncategories: []\n---\n\n\n## Background\n\nIf $Y$ includes related samples, why is it beneficial to adjust for PRS, or to take residuals from the LMM, in order to perform regression without the issue of non-independence?\n\nData generating model:\n\n$$\nY = \\sigma^2_g K + \\sigma^2_e I\n$$\n\nwhere $K$ is the kinship matrix and $I$ is the identity matrix. \n\nThe PRS is an estimate of $\\sigma^2_g K$, which means the residual of $Y$ will reduce to the uncorrelated term $\\sigma^2_e I$. However it's not clear how well the PRS method will work if it's an imperfect measure of $\\sigma^2_g K$, and it also is a question as to whether correcting for the complete or incomplete PRS will help with vQTL estimates.\n\n\n1. Create y from lots of gs\n2. duplicate some values of y\n3. regress x on y \n4. predict y from gs and adjust for prediction\n5. regression x on y resid\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(dplyr)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\n\nAttaching package: 'dplyr'\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nThe following objects are masked from 'package:stats':\n\n    filter, lag\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nThe following objects are masked from 'package:base':\n\n    intersect, setdiff, setequal, union\n```\n\n\n:::\n\n```{.r .cell-code}\nlibrary(ggplot2)\n\ngroup_size <- 20\nngroup <- 50\nn <- group_size * ngroup\np <- 100\ng <- matrix(rbinom(group_size * p, 2, 0.5), group_size, p)\nbetas <- rnorm(p)\n\nprs <- rep(scale(g %*% betas), each=ngroup)\ne <- rnorm(n)\ny <- (prs + e) %>% scale %>% drop\n```\n:::\n\n\nNow generate estimates of the PRS. \n\n- Betas are imperfectly estimates\n- Only some Betas are included\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbetahat <- rnorm(p, betas)\nprshat1 <- rep(scale(g %*% betahat), each=ngroup)\nprshat2 <- rep(scale(g[,1:(p/2)] %*% betas[1:(p/2)]), each=ngroup)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\npairs(cbind(prs, prshat1, prshat2))\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-3-1.png){width=672}\n:::\n:::\n\n\nGenerate residuals\n\n\n::: {.cell}\n\n```{.r .cell-code}\nyresid <- residuals(lm(y ~ prs)) %>% scale %>% drop\nyresidhat1 <- residuals(lm(y ~ prshat1)) %>% scale %>% drop\nyresidhat2 <- residuals(lm(y ~ prshat2)) %>% scale %>% drop\npairs(cbind(y, yresid, yresidhat1, yresidhat2))\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-4-1.png){width=672}\n:::\n:::\n\n\nFunction for vQTL estimation\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndrm <- function(g, y) {\n  y.i <- tapply(y, g, median, na.rm=T)  \n  z.ij <- abs(y - y.i[g+1])\n  summary(lm(z.ij ~ g))$coef %>%\n    as_tibble() %>%\n    slice(2) %>%\n    mutate(method=\"drm\")\n}\n\nadd <- function(g, y) {\n    summary(lm(y ~ g))$coef %>%\n    as_tibble() %>%\n    slice(2) %>%\n    mutate(method=\"add\")\n}\n```\n:::\n\n\nRun simulations\n\n- Null SNP\n- Strong relatedness\n- Y is adjusted for different levels of PRS\n- Additive (`add`) and vQTL models (`drm`)\n- 1000 replicates\n\n\n::: {.cell}\n\n```{.r .cell-code}\nparams <- expand.grid(\n    y_options = c(\"y\", \"yresid\", \"yresidhat1\", \"yresidhat2\"),\n    method_options = c(\"drm\", \"add\"),\n    stringsAsFactors=FALSE\n)\n\nsims <- lapply(1:1000, \\(i) {\n    SNP <- rep(rbinom(group_size, 2, 0.5), each = ngroup)\n    lapply(1:nrow(params), \\(j) {\n        m <- get(params$method_options[j])\n        yo <- get(params$y_options[j])\n        m(SNP, yo) %>% mutate(what = params$y_options[j])\n    }) %>% bind_rows()\n\n}) %>% bind_rows()\nnames(sims) <- c(\"b\", \"se\", \"tval\", \"pval\", \"method\", \"what\")\nsims\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 7,984 × 6\n          b     se   tval     pval method what      \n      <dbl>  <dbl>  <dbl>    <dbl> <chr>  <chr>     \n 1  0.0695  0.0216  3.22  1.31e- 3 drm    y         \n 2  0.0112  0.0222  0.503 6.15e- 1 drm    yresid    \n 3  0.00680 0.0214  0.318 7.51e- 1 drm    yresidhat1\n 4  0.0108  0.0212  0.511 6.10e- 1 drm    yresidhat2\n 5 -0.0627  0.0365 -1.72  8.63e- 2 add    y         \n 6 -0.0393  0.0366 -1.07  2.83e- 1 add    yresid    \n 7 -0.224   0.0359 -6.23  6.70e-10 add    yresidhat1\n 8 -0.281   0.0355 -7.91  6.70e-15 add    yresidhat2\n 9  0.162   0.0308  5.26  1.72e- 7 drm    y         \n10  0.0141  0.0327  0.432 6.66e- 1 drm    yresid    \n# ℹ 7,974 more rows\n```\n\n\n:::\n:::\n\n\nMean absolute values from the simulations\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsims %>% group_by(method, what) %>% summarise(b=mean(abs(b)), se=mean(se), pval=mean(pval), tval=mean(abs(tval)))\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\n`summarise()` has grouped output by 'method'. You can override using the\n`.groups` argument.\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 8 × 6\n# Groups:   method [2]\n  method what            b     se  pval  tval\n  <chr>  <chr>       <dbl>  <dbl> <dbl> <dbl>\n1 add    y          0.204  0.0460 0.116 4.53 \n2 add    yresid     0.0485 0.0467 0.415 1.04 \n3 add    yresidhat1 0.183  0.0462 0.129 4.03 \n4 add    yresidhat2 0.194  0.0461 0.125 4.28 \n5 drm    y          0.0778 0.0273 0.174 2.88 \n6 drm    yresid     0.0179 0.0283 0.568 0.630\n7 drm    yresidhat1 0.0597 0.0271 0.220 2.21 \n8 drm    yresidhat2 0.0714 0.0274 0.186 2.62 \n```\n\n\n:::\n:::\n\n\n\nLook at difference in betas\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(sims, aes(x=b)) +\ngeom_density(aes(fill=what), alpha=0.5) +\nfacet_grid(method ~ .)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-8-1.png){width=672}\n:::\n:::\n\n\n\n## Summary\n\n- Full adjustment for PRS will remove type 1 error for both vQTLs and additive effects\n- The standard error is not affected by the adjustment\n- The betas are attenuated when PRS is more effectively captured\n\n\n---\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsessionInfo()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nR version 4.5.1 (2025-06-13)\nPlatform: aarch64-apple-darwin20\nRunning under: macOS Sonoma 14.6.1\n\nMatrix products: default\nBLAS:   /Library/Frameworks/R.framework/Versions/4.5-arm64/Resources/lib/libRblas.0.dylib \nLAPACK: /Library/Frameworks/R.framework/Versions/4.5-arm64/Resources/lib/libRlapack.dylib;  LAPACK version 3.12.1\n\nlocale:\n[1] en_US.UTF-8/en_US.UTF-8/en_US.UTF-8/C/en_US.UTF-8/en_US.UTF-8\n\ntime zone: Europe/London\ntzcode source: internal\n\nattached base packages:\n[1] stats     graphics  grDevices utils     datasets  methods   base     \n\nother attached packages:\n[1] ggplot2_3.5.2 dplyr_1.1.4  \n\nloaded via a namespace (and not attached):\n [1] vctrs_0.6.5        cli_3.6.5          knitr_1.50         rlang_1.1.6       \n [5] xfun_0.52          generics_0.1.4     jsonlite_2.0.0     labeling_0.4.3    \n [9] glue_1.8.0         htmltools_0.5.8.1  scales_1.4.0       rmarkdown_2.29    \n[13] grid_4.5.1         evaluate_1.0.4     tibble_3.3.0       fastmap_1.2.0     \n[17] yaml_2.3.10        lifecycle_1.0.4    compiler_4.5.1     RColorBrewer_1.1-3\n[21] htmlwidgets_1.6.4  pkgconfig_2.0.3    farver_2.1.2       digest_0.6.37     \n[25] R6_2.6.1           utf8_1.2.6         tidyselect_1.2.1   pillar_1.11.0     \n[29] magrittr_2.0.3     withr_3.0.2        tools_4.5.1        gtable_0.3.6      \n```\n\n\n:::\n:::\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}