{
  "hash": "1dd4fbddfa9a09260747e725628dbdcb",
  "result": {
    "markdown": "---\ntitle: \"Heterogeneity in cell-type interaction model\"\nauthor: Gibran Hemani\ndate: \"2023-11-28\"\ncategories: []\n---\n\n\n## Background\n\nTwo models\n\n- Estimate mQTL in purified cells. Marginal effects obtained per cell type. Can estimate heterogeneity between of mQTL effect estimates across cell types\n- Estimate G x celltype proportion interaction for each celltype. Interaction is a deviation fron mean effect. Quite a complex model Can we just estimate heterogeneity between interaction terms?\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(ggplot2)\nlibrary(dplyr)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n\nAttaching package: 'dplyr'\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nThe following objects are masked from 'package:stats':\n\n    filter, lag\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nThe following objects are masked from 'package:base':\n\n    intersect, setdiff, setequal, union\n```\n:::\n\n```{.r .cell-code}\nsim <- function(nc, n, betas = runif(nc, -2, 2)) {\n    g <- rbinom(n, 2, 0.4)\n    \n    m <- sapply(1:nc, function(i)\n    {\n        g * betas[i] + rnorm(n)\n    })\n    # for each individual sample cell type proportions\n    cellprop <- sapply(1:n, function(x) {a <- runif(nc); a/sum(a)}) %>% t()\n    # weighted sum\n    M <- (scale(m) * cellprop) %>% rowSums\n\n    res <- lapply(1:nc, function(i)\n    {\n        o <- summary(lm(M ~ g * cellprop[,i]))\n        tibble(cell=i, b=o$coef[4,1], se=o$coef[4,2], pval=o$coef[4,4], method=\"interaction\")\n    }) %>% bind_rows()\n\n    res2 <- lapply(1:nc, function(i)\n    {\n        o <- summary(lm(m[,i] ~ g))\n        tibble(cell=i, b=o$coef[2,1], se=o$coef[2,2], pval=o$coef[2,4], method=\"marginal\")\n    }) %>% bind_rows()\n\n    betas <- tibble(cell=1:nc, b=betas, method=\"true\")\n    \n\n    # cellprop <- as_tibble(cellprop)\n    # m <- as_tibble(m)\n    # names(m) <- paste0(\"m\", 1:nc)\n    # names(cellprop) <- paste0(\"cp\", 1:nc)\n    # cellprop$M <- M\n    # cellprop$g <- g\n\n    # cellprop <- bind_cols(cellprop, m)\n\n    # return(tibble(int=res, marg=res2, betas))\n\n    # heterogeneity\n    het <- bind_rows(\n        fixed_effects_meta_analysis(res$b, res$se) %>% \n            as_tibble() %>%\n            slice_head(n=1) %>%\n            mutate(method=\"interaction\"),\n        fixed_effects_meta_analysis(res2$b, res2$se) %>% \n            as_tibble() %>%\n            slice_head(n=1) %>%\n            mutate(method=\"marginal\"),\n    )\n\n    effs <- bind_rows(res, res2, betas)\n    return(list(effs=effs, het=het))\n}\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# Provide vector of interaction betas and their standard errors\nfixed_effects_meta_analysis <- function(beta_vec, se_vec) {\n    w <- 1 / se_vec^2\n    beta <- sum(beta_vec * w, na.rm=T) / sum(w, na.rm=T)\n    se <- sqrt(1 / sum(w, na.rm=T))\n    pval <- pnorm(abs(beta / se), lower.tail = FALSE)\n    Qj <- w * (beta-beta_vec)^2\n    Q <- sum(Qj, na.rm=T)\n    Qdf <- sum(!is.na(beta_vec))-1\n    if(Qdf == 0) Q <- 0\n    Qjpval <- pchisq(Qj, 1, lower.tail=FALSE)\n    Qpval <- pchisq(Q, Qdf, lower.tail=FALSE)\n    pv <- pnorm(abs(beta_vec)/se_vec, lower.tail=FALSE)\n    min_pv <- min(pv, na.rm=T)\n    return(list(beta=beta, se=se, Q=Q, Qdf=Qdf, Qpval=Qpval, Qj=Qj, Qjpval=Qjpval, min_pv=min_pv))\n}\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nparam <- expand.grid(\n    nc=5,\n    n=seq(100,1000, by=50),\n    bsd=0.4,\n    nsim=1:100\n)\ndim(param)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1900    4\n```\n:::\n\n```{.r .cell-code}\nr <- lapply(1:nrow(param), function(i) {\n    o <- sim(param$nc[i], param$n[i], rnorm(param$nc[i], sd=param$bsd[i]))\n    bind_rows(\n        param[i,] %>% mutate(Qpval=o$het$Qpval[1], method=\"interaction\"),\n        param[i,] %>% mutate(Qpval=o$het$Qpval[2], method=\"marginal\")\n    )\n}) %>% bind_rows()\n\nr %>% group_by(n, method) %>%\n    summarise(pow=sum(Qpval < 0.05)/n()) %>%\n    ggplot(., aes(x=n, y=pow)) +\n    geom_point(aes(colour=method)) +\n    geom_line(aes(colour=method))\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n`summarise()` has grouped output by 'n'. You can override using the `.groups`\nargument.\n```\n:::\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-3-1.png){width=672}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(r, aes(x=as.factor(n), y=-log10(Qpval))) +\n    geom_boxplot(aes(colour=method))\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-4-1.png){width=672}\n:::\n:::\n\n\n## Summary\n\n- Heterogeneity estimate seems ok\n- Interaction model is very low power compared to marginal cell estimates\n\n---\n\n## Ignore\n\n\n::: {.cell}\n\n```{.r .cell-code}\nd <- sim(2, 1000)\n\nsim(5, 1000, b=rnorm(5, sd=0.4))\nsim(2, 10000, c(1,2))\n\n\nn <- 10000\nnc <- 2\nbetas <- c(1,2)\ng <- rbinom(n, 2, 0.4)\n\nm <- sapply(1:nc, function(i) {\n    g * betas[i] + rnorm(n)\n})\n# for each individual sample cell type proportions\ncp <- sapply(1:n, function(x) {a <- runif(nc); a/sum(a)}) %>% t()\n# weighted sum\nM <- (scale(m) * cp) %>% rowSums\n\ncov(M, g * cp[,1]) / var(g*cp[,1])\n\nsummary(lm(M ~ g*cp[,1]))\n\nsummary(lm(M ~ g))\ncov(M, g) / var(g)\n\nsummary(lm(M ~ cp[,1]))\ncov(M, cp[,1]) / var(cp[,1])\n\nsummary(lm(M ~ g*cp[,1]))\ncov(M, g*cp[,1]) / var(g*cp[,1])\n\nMr <- residuals(lm(M ~ g+cp[,1]))\nsummary(lm(Mr ~ g:cp[,1]))\ncov(Mr, g*cp[,1]) / var(g*cp[,1])\n\n\n\n\nsummary(lm(M ~ g:cp[,1]))\ncov(M, cp[,1]) / var(cp[,1])\n\n\nsummary(lm(M ~ g * cp1, d))\nsummary(lm(m1 ~ g, d))\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nsim2 <- function(nc, n, betas = runif(nc, -2, 2)) {\n    g <- rbinom(n, 2, 0.4)\n    \n    m <- sapply(1:nc, function(i)\n    {\n        g * betas[i] + rnorm(n)\n    })\n    # for each individual sample cell type proportions\n    cellprop <- sapply(1:n, function(x) {a <- runif(nc); a/sum(a)}) %>% t()\n    # weighted sum\n    M <- (scale(m) * cellprop) %>% rowSums\n\n    res <- lapply(1:nc, function(i)\n    {\n        o <- summary(lm(M ~ g * cellprop[,i]))\n        tibble(cell=i, b=o$coef[4,1], se=o$coef[4,2], pval=o$coef[4,4], method=\"interaction\")\n    }) %>% bind_rows()\n\n    res2 <- lapply(1:nc, function(i)\n    {\n        o <- summary(lm(m[,i] ~ g))\n        tibble(cell=i, b=o$coef[2,1], se=o$coef[2,2], pval=o$coef[2,4], method=\"marginal\")\n    }) %>% bind_rows()\n\n    betas <- tibble(cell=1:nc, b=betas, method=\"true\")\n    \n\n    cellprop <- as_tibble(cellprop)\n    m <- as_tibble(m)\n    names(m) <- paste0(\"m\", 1:nc)\n    names(cellprop) <- paste0(\"cp\", 1:nc)\n    cellprop$M <- M\n    cellprop$g <- g\n\n    cellprop <- bind_cols(cellprop, m)\n    return(cellprop)\n}\n\nana <- function(d) {\n    nc <- length(grep(\"cp\", names(d)))\n\n    # per cell estimates\n    o1 <- lapply(1:nc, \\(x) { \n        f <- paste0(\"M ~ g * cp\", x)\n        o <- summary(lm(f, data=d))$coef\n        n <- rownames(o)\n        o <- as_tibble(o)\n        names(o) <- c(\"b\", \"se\", \"tval\", \"pval\")\n        o$term <- n\n        o$cell <- x\n        o$mod <- \"interaction\"\n        o\n    }) %>% bind_rows()\n\n    # cell int estimates\n    o2 <- lapply(1:nc, \\(x) { \n        f <- paste0(\"m\", x, \" ~ g\")\n        o <- summary(lm(f, data=d))$coef\n        n <- rownames(o)\n        o <- as_tibble(o)\n        names(o) <- c(\"b\", \"se\", \"tval\", \"pval\")\n        o$term <- n\n        o$cell <- x\n        o$mod <- \"marginal\"\n        o\n    }) %>% bind_rows()\n    bind_rows(o1, o2)\n}\nd <- sim2(2, 1000)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: The `x` argument of `as_tibble.matrix()` must have unique column names if\n`.name_repair` is omitted as of tibble 2.0.0.\nâ„¹ Using compatibility `.name_repair`.\n```\n:::\n\n```{.r .cell-code}\nana(d) %>% as.data.frame\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n              b         se        tval          pval        term cell\n1   0.465602983 0.06112157   7.6176547  5.994846e-14 (Intercept)    1\n2  -0.685796058 0.05872337 -11.6784187  1.268203e-29           g    1\n3   0.513953777 0.11109149   4.6264011  4.211167e-06         cp1    1\n4  -0.491006953 0.10538418  -4.6592094  3.604804e-06       g:cp1    1\n5   0.979556760 0.06188496  15.8286714  1.658308e-50 (Intercept)    2\n6  -1.176803011 0.05829833 -20.1858778  3.135017e-76           g    2\n7  -0.513953777 0.11109149  -4.6264011  4.211167e-06         cp2    2\n8   0.491006953 0.10538418   4.6592094  3.604804e-06       g:cp2    2\n9   0.021219262 0.04455143   0.4762869  6.339742e-01 (Intercept)    1\n10 -1.814232687 0.04290938 -42.2805626 1.112888e-224           g    1\n11  0.009644626 0.04697208   0.2053268  8.373587e-01 (Intercept)    2\n12 -0.824782042 0.04524081 -18.2309294  2.550133e-64           g    2\n           mod\n1  interaction\n2  interaction\n3  interaction\n4  interaction\n5  interaction\n6  interaction\n7  interaction\n8  interaction\n9     marginal\n10    marginal\n11    marginal\n12    marginal\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ncov(residuals(lm(M ~ g + cp1, d)), d$g*d$cp1) / var(d$g*d$cp1)\ncov(d$M, d$g*d$cp1) / var(d$g*d$cp1)\nsummary(lm(M ~ g*cp1, d))\ncov(d$M, d$g) / var(d$g)\n\nsummary(lm(M ~ g + cp1, d))\nsummary(lm(M ~ g + cp1 + g*cp1, d))\nsummary(lm(M ~ g + cp1 + g*cp1 + cp2 + g*cp2, d))\n\n\nr <- residuals(lm(M ~ g + cp1, d))\n\nsummary(lm(r ~ g*cp1, d))\ncov(d$cp1)\n\nn <- 10000\na <- rnorm(n, m=0 sd=10)\nb <- rnorm(n, sd=3)\ny <- a + b - 4*a*b + rnorm(n)\n\ncov(y, a*b) / var(a*b)\nsummary(lm(y ~ a*b))\n```\n:::\n\n\n---\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsessionInfo()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nR version 4.3.2 (2023-10-31)\nPlatform: aarch64-apple-darwin20 (64-bit)\nRunning under: macOS Ventura 13.6\n\nMatrix products: default\nBLAS:   /Library/Frameworks/R.framework/Versions/4.3-arm64/Resources/lib/libRblas.0.dylib \nLAPACK: /Library/Frameworks/R.framework/Versions/4.3-arm64/Resources/lib/libRlapack.dylib;  LAPACK version 3.11.0\n\nlocale:\n[1] en_GB.UTF-8/en_GB.UTF-8/en_GB.UTF-8/C/en_GB.UTF-8/en_GB.UTF-8\n\ntime zone: Europe/London\ntzcode source: internal\n\nattached base packages:\n[1] stats     graphics  grDevices utils     datasets  methods   base     \n\nother attached packages:\n[1] dplyr_1.1.4   ggplot2_3.4.2\n\nloaded via a namespace (and not attached):\n [1] vctrs_0.6.4       cli_3.6.1         knitr_1.45        rlang_1.1.2      \n [5] xfun_0.41         generics_0.1.3    jsonlite_1.8.7    labeling_0.4.2   \n [9] glue_1.6.2        colorspace_2.1-0  htmltools_0.5.7   scales_1.2.1     \n[13] fansi_1.0.5       rmarkdown_2.25    grid_4.3.2        evaluate_0.23    \n[17] munsell_0.5.0     tibble_3.2.1      fastmap_1.1.1     yaml_2.3.7       \n[21] lifecycle_1.0.4   compiler_4.3.2    htmlwidgets_1.6.3 pkgconfig_2.0.3  \n[25] farver_2.1.1      digest_0.6.33     R6_2.5.1          tidyselect_1.2.0 \n[29] utf8_1.2.4        pillar_1.9.0      magrittr_2.0.3    withr_2.5.2      \n[33] tools_4.3.2       gtable_0.3.3     \n```\n:::\n:::\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}