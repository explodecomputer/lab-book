{
  "hash": "d6e2d1370c6b662ff69ea45f2c9fe5fd",
  "result": {
    "markdown": "---\ntitle: \"Cross group effect comparison\"\nauthor: Gibran Hemani\ndate: \"2023-06-07\"\ncategories: []\n---\n\n\n## Background\n\nGWAS being performed on multiple ancestries, then meta-analysing to mitigate problems of LD tagging. QUESTION - how to determine rate of agreement of associations across ancestries. Power differs due to different allele frequencies and sample sizes (reflected in the SE of the assoc).\n\n- How often does the sign in pop1 agree with the sign in pop2?\n- Test statistic comparing observed vs replication rates\n\n\n\nSimulate 100 effects for 3 populations. For each population select a few SNPs to be null, otherwise all SNPs have the same effect in each population. Each population has a different sample size.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(simulateGP)\nlibrary(dplyr)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n\nAttaching package: 'dplyr'\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nThe following objects are masked from 'package:stats':\n\n    filter, lag\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nThe following objects are masked from 'package:base':\n\n    intersect, setdiff, setequal, union\n```\n:::\n\n```{.r .cell-code}\nlibrary(tidyr)\nlibrary(ggplot2)\nmap <- tibble(snp=paste0(\"rs\",1:100), af=runif(100, 0.01, 0.99))\nparams <- generate_gwas_params(map=map, h2=0.2, S=-0.4, Pi=1)\n\ntemp <- params; temp$beta[1:10] <- 0\nss_eur <- generate_gwas_ss(temp, 100000)\n\ntemp <- params; temp$beta[11:20] <- 0\nss_afr <- generate_gwas_ss(temp, 10000)\n\ntemp <- params; temp$beta[15:30] <- 0\nss_sas <- generate_gwas_ss(temp, 30000)\n```\n:::\n\n\nSo now each population has SNP effect estimates for 100 SNPs, an example of what the dataset looks like:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nss_eur\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 100 × 7\n   snp      af      se     bhat   fval      n  pval\n   <chr> <dbl>   <dbl>    <dbl>  <dbl>  <dbl> <dbl>\n 1 rs1   0.330 0.00476 -0.00147 0.0960 100000 0.757\n 2 rs2   0.229 0.00532 -0.00110 0.0430 100000 0.836\n 3 rs3   0.133 0.00658  0.0100  2.33   100000 0.127\n 4 rs4   0.417 0.00454  0.00134 0.0873 100000 0.768\n 5 rs5   0.190 0.00570 -0.00276 0.235  100000 0.628\n 6 rs6   0.362 0.00465  0.00309 0.442  100000 0.506\n 7 rs7   0.273 0.00502 -0.00535 1.13   100000 0.287\n 8 rs8   0.497 0.00447  0.00192 0.184  100000 0.668\n 9 rs9   0.195 0.00564 -0.00308 0.298  100000 0.585\n10 rs10  0.426 0.00452  0.00524 1.34   100000 0.246\n# ℹ 90 more rows\n```\n:::\n:::\n\n\n## Heterogeneity\n\nFor each SNP test for heterogeneity of effects between populations. This uses Cochrane's Q test statistic.\n\nAnalysis functions:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfixed_effects_meta_analysis <- function(beta_vec, se_vec)\n{\n    w <- 1 / se_vec^2\n    beta <- sum(beta_vec * w) / sum(w)\n    se <- sqrt(1 / sum(w))\n    pval <- pnorm(abs(beta / se), lower.tail = FALSE)\n    Qj <- w * (beta-beta_vec)^2\n    Q <- sum(Qj)\n    Qdf <- length(beta_vec)-1\n    Qjpval <- pchisq(Qj, 1, lower.tail=FALSE)\n    Qpval <- pchisq(Q, Qdf, lower.tail=FALSE)\n    return(list(beta=beta, se=se, Qpval=Qpval, Qj=Qj, Qjpval=Qjpval))\n}\n# fixed_effects_meta_analysis(c(1,2,3), c(0.3, 0.3, 0.3))\n# fixed_effects_meta_analysis(c(1,1,1), c(0.3, 0.3, 0.3))\n\n#' Test for heterogeneity of effect estimates between populations\n#' \n#' @description For each SNP this function will provide a Cochran's Q test statistic - a measure of heterogeneity of effect sizes between populations. A low p-value means high heterogeneity.\n#' In addition, for every SNP it gives a per population p-value - this can be interpreted as asking for each SNP is a particular giving an outlier estimate.\n#' \n#' @param sslist Named list of data frames, one for each population, with at least bhat, se and snp columns\n#' \n#' @return List\n#' - Q = vector of p-values for Cochrane's Q statistic for each SNP\n#' - Qj = Data frame of per-population outlier q values for each SNP\nheterogeneity_test <- function(sslist) \n{\n    b <- lapply(sslist, \\(x) x$bhat) %>% bind_cols\n    se <- lapply(sslist, \\(x) x$se) %>% bind_cols\n    o <- lapply(1:nrow(b), \\(i) {\n        fixed_effects_meta_analysis(as.numeric(b[i,]), as.numeric(se[i,]))\n    })\n    Q <- tibble(snp = sslist[[1]]$snp, Qpval = sapply(o, \\(x) x$Qpval))\n    Qj <- lapply(o, \\(x) x$Qjpval) %>% do.call(rbind, .) %>% \n        as_tibble() %>%\n        rename(setNames(paste0(\"V\", 1:length(sslist)), names(sslist))) %>%\n        mutate(snp = sslist[[1]]$snp)\n    return(list(Q=Q, Qj=Qj))\n}\n```\n:::\n\n\nRun analysis:\n\n\n::: {.cell}\n\n```{.r .cell-code}\no <- heterogeneity_test(list(eur=ss_eur, afr=ss_afr, sas=ss_sas))\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: The `x` argument of `as_tibble.matrix()` must have unique column names if\n`.name_repair` is omitted as of tibble 2.0.0.\nℹ Using compatibility `.name_repair`.\n```\n:::\n\n```{.r .cell-code}\no$Q\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 100 × 2\n   snp      Qpval\n   <chr>    <dbl>\n 1 rs1   1.19e-18\n 2 rs2   1.00e-16\n 3 rs3   4.70e-27\n 4 rs4   3.01e- 6\n 5 rs5   2.31e-12\n 6 rs6   1.31e- 2\n 7 rs7   1.75e- 8\n 8 rs8   3.59e- 3\n 9 rs9   1.94e- 4\n10 rs10  9.73e- 1\n# ℹ 90 more rows\n```\n:::\n\n```{.r .cell-code}\nggplot(o$Q, aes(x=snp, y=-log10(Qpval))) +\ngeom_point() +\ngeom_hline(yintercept=-log10(0.05/nrow(o$Q)))\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-4-1.png){width=672}\n:::\n:::\n\n\nThis shows the heterogeneity for each SNP. Alternatively we could look at the contribution of each population to the heterogeneity of each SNP\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngather(as.data.frame(o$Qj), \"key\", \"value\", -snp) %>%\nggplot(., aes(x=snp, y=-log10(value))) +\ngeom_point(aes(colour=key)) +\nscale_colour_brewer(type=\"qual\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-5-1.png){width=672}\n:::\n:::\n\n\nWe could then dig deeper and look at the per-population estimates for the SNPs that have some heterogeneity\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Which SNPs have heterogeneity after multiple testing correction\nindex <- which(o$Q$Qpval < 0.05/nrow(o$Q))\n\n# Get per-population effect estimates for those SNPs\n# Make forest plots\nbind_rows(\n    ss_eur[index,] %>% mutate(pop=\"eur\"),\n    ss_afr[index,] %>% mutate(pop=\"afr\"),\n    ss_sas[index,] %>% mutate(pop=\"sas\")\n) %>% ggplot(., aes(x=bhat, y=pop)) +\ngeom_point(aes(colour=pop)) +\ngeom_errorbarh(aes(colour=pop, xmin=bhat-se*1.96, xmax=bhat+se*1.96), height=0) +\nfacet_grid(snp ~ .) +\ngeom_vline(xintercept=0, linetype=\"dotted\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-6-1.png){width=672}\n:::\n:::\n\n\n\n## Expected vs observed replication\n\nThis might not be as useful as the heterogeneity stuff above, but some example code below\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#' Expected vs observed replication rates\n#' \n#' @description For a set of effects that have discovery and replication betas and SEs, this function determines the extent to which the observed replication rate matches the expected replication rate. \n#' The expected replication rate is based on the assumption that the replication dataset has the same effect sizes but that the power may be different (e.g. due to allele frequencies or sample sizes) and is reflected in the replication standard errors. \n#' It assesses replication based on concordance of effect direction across discovery and replication, and p-values surpassing a user-specified p-value threshold.\n#' \n#' @param b_disc vector of clumped incidence hit effects\n#' @param se_disc the standard errors for incidence effects\n#' @param b_rep corresponding vector of associations in progression\n#' @param se_rep standard errors of effects in progression\n#' @param alpha p-value threshold to check for replication of incidence hits in progression (e.g. try 0.05 or 1e-5)\nexpected_vs_observed_replication <- function(b_disc, b_rep, se_disc, se_rep, alpha)\n{\n    p_sign <- pnorm(-abs(b_disc) / se_disc) * pnorm(-abs(b_disc) / se_rep) + ((1 - pnorm(-abs(b_disc) / se_disc)) * (1 - pnorm(-abs(b_disc) / se_rep)))\n    p_sig <- pnorm(-abs(b_disc) / se_rep + qnorm(alpha / 2)) + (1 - pnorm(-abs(b_disc) / se_rep - qnorm(alpha / 2)))\n    p_rep <- pnorm(abs(b_rep)/se_rep, lower.tail=FALSE)\n    res <- tibble::tibble(\n        nsnp=length(b_disc),\n        metric=c(\"Sign\", \"Sign\", \"P-value\", \"P-value\"),\n        datum=c(\"Expected\", \"Observed\", \"Expected\", \"Observed\"),\n        value=c(sum(p_sign, na.rm=TRUE), sum(sign(b_disc) == sign(b_rep)), sum(p_sig, na.rm=TRUE), sum(p_rep < alpha, na.rm=TRUE)),\n        pdiff=c(NA_real_, binom.test(value[2], nsnp[2], value[1]/nsnp[2])$p.value, NA_real_, binom.test(value[4], nsnp[4], value[3]/nsnp[4])$p.value)\n    )\n    res_per_variant <- tibble(\n        expected_pval = p_sig,\n        observed_pval = p_rep < alpha,\n        replication_fail = expected_pval > 0.95 & ! observed_pval,\n        expected_sign = p_sign,\n        observed_sign = sign(b_disc) == sign(b_rep),\n        sign_fail = expected_sign > 0.95 & ! observed_sign\n    )\n    return(list(res=res, variants=res_per_variant))\n}\n\nforest_plot <- function(sslist, snp)\n{\n    tibble(\n        beta = sapply(sslist, \\(x) x$bhat[snp]),\n        se = sapply(sslist, \\(x) x$se[snp]),\n        label = names(sslist)\n    ) %>%\n    ggplot(., aes(x=beta, y=label)) +\n    geom_point() +\n    geom_errorbarh(aes(xmin=beta-se*1.96, xmax=beta+se*1.96), height=0) +\n    geom_vline(xintercept=0, linetype=\"dotted\") +\n    labs(x=\"beta\", y=\"population\")\n}\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nindex <- which(ss_eur$pval < 5e-8)\no_eur_afr <- expected_vs_observed_replication(ss_eur$bhat[index], ss_afr$bhat[index], ss_eur$se[index], ss_afr$se[index], 0.05)\no_eur_afr\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$res\n# A tibble: 4 × 5\n   nsnp metric  datum    value       pdiff\n  <int> <chr>   <chr>    <dbl>       <dbl>\n1    59 Sign    Expected  58.7 NA         \n2    59 Sign    Observed  54    0.00000976\n3    59 P-value Expected  52.1 NA         \n4    59 P-value Observed  48    0.103     \n\n$variants\n# A tibble: 59 × 6\n   expected_pval observed_pval replication_fail expected_sign observed_sign\n           <dbl> <lgl>         <lgl>                    <dbl> <lgl>        \n 1         1.00  TRUE          FALSE                    1     TRUE         \n 2         1.00  FALSE         TRUE                     1.00  FALSE        \n 3         1.00  TRUE          FALSE                    1.00  FALSE        \n 4         0.996 FALSE         TRUE                     1.00  TRUE         \n 5         1.00  FALSE         TRUE                     1.00  TRUE         \n 6         0.940 FALSE         FALSE                    1.00  FALSE        \n 7         0.765 FALSE         FALSE                    0.996 FALSE        \n 8         1     FALSE         TRUE                     1     FALSE        \n 9         1.00  TRUE          FALSE                    1     TRUE         \n10         0.996 TRUE          FALSE                    1.00  TRUE         \n# ℹ 49 more rows\n# ℹ 1 more variable: sign_fail <lgl>\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nforest_plot(list(eur=ss_eur, afr=ss_afr, sas=ss_sas), index[which(o_eur_afr$variants$sign_fail)[3]])\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-9-1.png){width=672}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nindex <- which(ss_afr$pval < 5e-8)\no_afr_sas <- expected_vs_observed_replication(ss_afr$bhat[index], ss_afr$bhat[index], ss_sas$se[index], ss_sas$se[index], 0.05)\no_afr_sas\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$res\n# A tibble: 4 × 5\n   nsnp metric  datum    value pdiff\n  <int> <chr>   <chr>    <dbl> <dbl>\n1    21 Sign    Expected    21    NA\n2    21 Sign    Observed    21     1\n3    21 P-value Expected    21    NA\n4    21 P-value Observed    21     1\n\n$variants\n# A tibble: 21 × 6\n   expected_pval observed_pval replication_fail expected_sign observed_sign\n           <dbl> <lgl>         <lgl>                    <dbl> <lgl>        \n 1             1 TRUE          FALSE                        1 TRUE         \n 2             1 TRUE          FALSE                        1 TRUE         \n 3             1 TRUE          FALSE                        1 TRUE         \n 4             1 TRUE          FALSE                        1 TRUE         \n 5             1 TRUE          FALSE                        1 TRUE         \n 6             1 TRUE          FALSE                        1 TRUE         \n 7             1 TRUE          FALSE                        1 TRUE         \n 8             1 TRUE          FALSE                        1 TRUE         \n 9             1 TRUE          FALSE                        1 TRUE         \n10             1 TRUE          FALSE                        1 TRUE         \n# ℹ 11 more rows\n# ℹ 1 more variable: sign_fail <lgl>\n```\n:::\n:::\n\n\n---\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsessionInfo()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nR version 4.3.0 (2023-04-21)\nPlatform: aarch64-apple-darwin20 (64-bit)\nRunning under: macOS Monterey 12.6.2\n\nMatrix products: default\nBLAS:   /Library/Frameworks/R.framework/Versions/4.3-arm64/Resources/lib/libRblas.0.dylib \nLAPACK: /Library/Frameworks/R.framework/Versions/4.3-arm64/Resources/lib/libRlapack.dylib;  LAPACK version 3.11.0\n\nlocale:\n[1] en_US.UTF-8/en_US.UTF-8/en_US.UTF-8/C/en_US.UTF-8/en_US.UTF-8\n\ntime zone: Europe/London\ntzcode source: internal\n\nattached base packages:\n[1] stats     graphics  grDevices utils     datasets  methods   base     \n\nother attached packages:\n[1] ggplot2_3.4.2    tidyr_1.3.0      dplyr_1.1.2      simulateGP_0.1.2\n\nloaded via a namespace (and not attached):\n [1] vctrs_0.6.2        cli_3.6.1          knitr_1.43         rlang_1.1.1       \n [5] xfun_0.39          purrr_1.0.1        generics_0.1.3     jsonlite_1.8.4    \n [9] labeling_0.4.2     glue_1.6.2         colorspace_2.1-0   htmltools_0.5.5   \n[13] scales_1.2.1       fansi_1.0.4        rmarkdown_2.22     grid_4.3.0        \n[17] munsell_0.5.0      evaluate_0.21      tibble_3.2.1       fastmap_1.1.1     \n[21] yaml_2.3.7         lifecycle_1.0.3    compiler_4.3.0     RColorBrewer_1.1-3\n[25] htmlwidgets_1.6.2  pkgconfig_2.0.3    rstudioapi_0.14    farver_2.1.1      \n[29] digest_0.6.31      R6_2.5.1           tidyselect_1.2.0   utf8_1.2.3        \n[33] pillar_1.9.0       magrittr_2.0.3     withr_2.5.0        gtable_0.3.3      \n[37] tools_4.3.0       \n```\n:::\n:::\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}