{
  "hash": "c8c3fd70181de0607eb1119e0a798c6e",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Conditional summary stats and imputation\"\nauthor: Gibran Hemani\ndate: \"2024-09-18\"\ncategories: []\nexecute: \n  eval: false\n---\n\n\n## Background\n\nData generating model\n\n$$\ny = Xb + e\n$$\n\nwhere $y$ is the phenotype, $X$ is the genotype matrix, $b$ is the effect sizes and $e$ is the error term. X is centred to have each column mean zero to avoid need to handle intercept terms.\n\nThe expected associations between each variant and y is\n\n$$\n\\beta = (X^T X)^{-1} X^T y\n$$\n\n\n::: {.cell}\n\n```{.r .cell-code}\nload(url(\"https://github.com/explodecomputer/lab-book/raw/refs/heads/main/posts/2024-09-18-conditional-summary-stats/1kg_region.rdata\"))\nlibrary(MASS)\nlibrary(dplyr)\n\nsolve2 <- function(A) {\n    eig <- eigen(A)\n    eig$values <- 1 / eig$values\n    return(eig$vectors %*% diag(eig$values) %*% t(eig$vectors))\n}\n\nsolve3 <- function(A, lambda=1e-6) {\n    solve(A + diag(nrow(A)) * lambda)\n}\n\nsim_mat <- function(n) {\n  p <- qr.Q(qr(matrix(rnorm(n^2), n)))\n  Sigma <- crossprod(p, p*(n:1))\n  v <- diag(Sigma)\n  Sigma <- diag(1/sqrt(v)) %*% Sigma %*% diag(1/sqrt(v))\n  v <- v / max(v) / 2\n  af <- (1 + sqrt(1-2*v)) / 2\n  return(list(R=Sigma, af=af))\n}\n# sim_mat(100)[[1]][1:10,1:10]\n\n\nsimulate_ss <- function(X, af, ncause, sigmag, seed=1234) {\n    set.seed(seed)\n    nsnp <- length(af)\n    nid <- nrow(X)\n    b <- rep(0, nsnp)\n    b[sample(1:nsnp, ncause)] <- rnorm(ncause, sd=sigmag)\n\n    e <- rnorm(nid)\n    y <- X %*% b + e \n    print(mean(y))\n\n    betahat <- sapply(1:nsnp, \\(i) {cov(X[,i], y) / var(X[,i])})\n    se <- sapply(1:nsnp, \\(i) {sqrt(var(y) / (var(X[,i] * sqrt(nid))))})\n    zhat <- betahat/se\n    pval <- 2 * pnorm(-abs(zhat))\n\n    betaexp <- MASS::ginv(t(X) %*% X) %*% t(X) %*% y\n    # betaexp <- solve3(t(X) %*% X) %*% t(X) %*% y\n    return(tibble(betahat, betaexp, b, se, zhat, pval, af))\n}\n\nX <- rbind(X, X, X, X)\n\nss <- simulate_ss(X, af, 20, 0.1)\n\nplot(ss$betahat)\nplot(ss$betaexp)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nplot(ss$betaexp, ss$betahat)\n```\n:::\n\n\nThis is equivalent to\n\n$$\n\\beta = D^{-1} R D b\n$$\n\nwhere $D$ is a diagonal matrix with the diagonal elements being the variance of the columns of $X$, $R$ is the correlation matrix of $X$ and $b$ is a vector of true effect sizes. Expect that $b$ is quite sparse, and can be estimated from finemapping methods.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nD <- diag(2 * af * (1 - af))\nDi <- diag(1 / diag(D))\nR <- cor(X)\nss$betahat2 <- sqrt(Di) %*% R %*% D %*% ss$b\nplot(ss$betahat2, ss$betaexp)\n```\n:::\n\n::: {.cell}\n\n:::\n\n\n$$\n\\beta = D^{-1} R D b\n$$\n\nwhere $D$ is a diagonal matrix with the diagonal elements being the variance of the columns of $X$, $R$ is the correlation matrix of $X$ and $b$ is a vector of true effect sizes. Expect that $b$ is quite sparse, and can be estimated from finemapping methods.\n\nIf there are $K$ causal variants, we would like to obtain $K$ versions of the summary statistics where each $k$th version is obtained by removing the effects of all other causal variants.\n\n$$\n\\hat{b}_{(v)} = D_{(v)} R^{-1}_{(v)} D^{-1}_{(v)} \\beta_{(v)}\n$$\n\nwhere $\\hat{b}_{(v)}$ is the vector true causal effect estimates for the $K$ causal variants only.\n\nSo the region-wide associations generated from all causal variants can be converted into a set of $K$ regional associations, where each represents the causal effect of one variant and with all other causal effects removed.\n\n$$\n\\hat{b}_{(k)} = \\beta - \\hat{b}_{(v)}\n$$\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsim_mat <- function(n, nid) {\n  p <- qr.Q(qr(matrix(rnorm(n^2), n)))\n  Sigma <- crossprod(p, p*(n:1))\n  v <- diag(Sigma)\n  Sigma <- diag(1/sqrt(v)) %*% Sigma %*% diag(1/sqrt(v))\n  v <- v / max(v) / 2\n  af <- (1 + sqrt(1-2*v)) / 2\n  X <- mvtnorm::rmvnorm(nid, rep(0, n), Sigma)\n  return(list(X=X, R=Sigma, af=af))\n}\n\nm <- sim_mat(100, 500)\nX <- m$X\n\nb <- rep(0, ncol(X))\nb[sample(1:ncol(X), 3)] <- rnorm(3, sd=10)\ny <- X %*% b + rnorm(nrow(X))\nb\nbexp <- solve(t(X) %*% X) %*% t(X) %*% y\nplot(bexp)\n\nbhat <- sapply(1:ncol(X), \\(i) {cov(X[,i], y) / var(X[,i])})\nplot(bhat)\n\nplot(bhat ~ bexp)\n\nR <- cor(X)\nR[1:10,1:10]\n\nD <- diag(apply(X, 2, var))\n\nplot(\n    c(sqrt(D) %*% R %*% sqrt(D))*(nrow(X)-1), \n    c(t(X) %*% X)\n)\n\nplot(\n    c(t(X) %*% y),\n    bhat %*% sqrt(D) * (nrow(X)-1)\n)\n\nXi <- solve(t(X) %*% X)\n\nRi <- solve(R)\n\n\n\n\n\n\n\n\n# sim_mat(100)[[1]][1:10,1:10]\n```\n:::\n\n\n\nI want there to be 3 causal variants. \n\nI will create summary statistics for all variants.\nThen SS for each variant removed.\n\nI want to recapitulate each variant removed.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nm <- sim_mat(100, 500)\nX <- m$X\nb <- rep(0, ncol(X))\nb[sample(1:ncol(X), 3)] <- rnorm(3, sd=10)\ne <- rnorm(nrow(X))\ny <- X %*% b + e\n\n# Generate summary stats for all variants\nbhat <- sapply(1:ncol(X), \\(i) {cov(X[,i], y) / var(X[,i])})\n\n# Expected summary stats\nD <- diag(apply(X, 2, var))\nDi <- diag(1 / diag(D))\nR <- cor(X)\nbexp <- Di %*% R %*% D %*% b\n\n# Generate summary stats for each variant on its own\nind <- which(b != 0)\nbhatcond <- lapply(ind, \\(i) {\n    bk <- b[i]\n    b <- rep(0, ncol(X))\n    b[i] <- bk\n    y <- X %*% b + e\n    bhat <- sapply(1:ncol(X), \\(i) {cov(X[,i], y) / var(X[,i])})\n    return(bhat)\n})\n\nbhatcondl <- lapply(1:length(bhatcond), \\(i) {\n    tibble(b=bhatcond[[i]], i, pos=1:length(b))\n}) %>% bind_rows() \n\nbhatcondl %>% ggplot(aes(x=pos, y=b)) + geom_point() + facet_grid(i ~ .)\n\n# simulate summary stats excluding each variant\nbcond <- lapply(seq_along(ind), \\(i) {\n    bt <- b\n    bt[ind[i]] <- 0\n    bsub <- Di %*% R %*% D %*% bt\n    bhat - bsub\n})\n\nbcondl <- lapply(1:length(bcond), \\(i) {\n    tibble(b=bcond[[i]], i, pos=1:length(b), what=\"bcond\")\n}) %>% bind_rows() \n\nbcondl %>% ggplot(aes(x=pos, y=b)) + geom_point() + facet_grid(i ~ .)\n\ninner_join(bhatcondl, bcondl, by=c(\"i\", \"pos\")) %>% ggplot(aes(x=b.x, y=b.y)) + geom_point() + geom_abline() + facet_grid(i ~ .)\n\n\nlapply(seq_along(ind), \\(i) {\n    cor(bhatcond[[i]], bcond[[i]])\n})\n```\n:::\n\n\n\nDo it again with genotype matrix\n\n\n::: {.cell}\n\n```{.r .cell-code}\nload(url(\"https://github.com/explodecomputer/lab-book/raw/refs/heads/main/posts/2024-09-18-conditional-summary-stats/1kg_region.rdata\"))\n\nb <- rep(0, ncol(X))\nb[sample(1:ncol(X), 3)] <- rnorm(3, sd=10)\ne <- rnorm(nrow(X))\ny <- X %*% b + e\n\n# Generate summary stats for all variants\nbhat <- sapply(1:ncol(X), \\(i) {cov(X[,i], y) / var(X[,i])})\nplot(bhat)\n\n# Expected summary stats\nD <- diag(apply(X, 2, var))\nDi <- diag(1 / diag(D))\nR <- cor(X)\nbexp <- sqrt(Di) %*% R %*% sqrt(D) %*% b\nplot(bexp)\n\nplot(bhat ~ bexp)\n\n# Generate summary stats for each variant on its own\nind <- which(b != 0)\nbhatcond <- lapply(ind, \\(i) {\n    bk <- b[i]\n    b <- rep(0, ncol(X))\n    b[i] <- bk\n    y <- X %*% b + e\n    bhat <- sapply(1:ncol(X), \\(i) {cov(X[,i], y) / var(X[,i])})\n    return(bhat)\n})\n\nbhatcondl <- lapply(1:length(bhatcond), \\(i) {\n    tibble(b=bhatcond[[i]], i, pos=1:length(b))\n}) %>% bind_rows() \n\nbhatcondl %>% ggplot(aes(x=pos, y=b)) + geom_point() + facet_grid(i ~ .)\n\n# simulate summary stats excluding each variant\nbcond <- lapply(seq_along(ind), \\(i) {\n    bt <- b\n    bt[ind[i]] <- 0\n    bsub <- sqrt(Di) %*% R %*% sqrt(D) %*% bt\n    bhat - bsub\n})\n\nbcondl <- lapply(1:length(bcond), \\(i) {\n    tibble(b=bcond[[i]], i, pos=1:length(b), what=\"bcond\")\n}) %>% bind_rows() \n\nbcondl %>% ggplot(aes(x=pos, y=b)) + geom_point() + facet_grid(i ~ .)\n\ninner_join(bhatcondl, bcondl, by=c(\"i\", \"pos\")) %>% ggplot(aes(x=b.x, y=b.y)) + geom_point() + geom_abline() + facet_grid(i ~ .)\n\n\nlapply(seq_along(ind), \\(i) {\n    cor(bhatcond[[i]], bcond[[i]])\n})\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ngenerate_marginals <- function(bhat, R, af, index) {\n    v <- 2 * af * (1 - af)\n    D <- diag(sqrt(v))\n    Di <- diag(1 / diag(D))\n\n    if(length(index) == 1) {\n        bhat2 <- bhat[index]\n    } else {\n        bhat2 <- (D[index,index] %*% MASS::ginv(R[index,index]) %*% Di[index,index] %*% bhat[index]) %>% drop()\n    }\n    b2 <- rep(0, nsnp)\n    b2[index] <- bhat2\n\n    bcond <- lapply(seq_along(index), \\(i) {\n        bt <- b2\n        bt[ind[i]] <- 0\n        bsub <- (sqrt(Di) %*% R %*% sqrt(D) %*% bt) %>% drop()\n        bhat - bsub\n    })\n    return(bcond)\n}\n\nbcond <- generate_marginals(bhat, R, af, which(b != 0))\n\nbcondl <- lapply(1:length(bcond), \\(i) {\n    tibble(b=bcond[[i]], i, pos=1:length(b), what=\"bcond\")\n}) %>% bind_rows() \n\nbcondl %>% ggplot(aes(x=pos, y=b)) + geom_point() + facet_grid(i ~ .)\n\ninner_join(bhatcondl, bcondl, by=c(\"i\", \"pos\")) %>% ggplot(aes(x=b.x, y=b.y)) + geom_point() + geom_abline() + facet_grid(i ~ .)\n```\n:::\n\n\n\n\n---\n\n\n\n## \n\n\n\n## True\n\nsstrue <- lapply(1:length(i), \\(j) {\n    bb <- ba\n    bb[i[-j]] <- 0\n    print(which(bb != 0))\n    beta_ld <- as.numeric(diag(1/xvar) %*% R %*% diag(xvar) %*% bb)\n    tibble(j, beta_ld, pos = 1:length(beta_ld))\n}) %>% bind_rows()\n\nsstrue\n\nggplot(sstrue, aes(x = pos, y=abs(beta_ld))) +\ngeom_point()  +\nfacet_grid(j ~ .)\n\ncor(sstrue$beta_ld, ss$bhj)\n\ninner_join(sstrue, ss, by=c(\"j\", \"pos\")) %>% \n    ggplot(aes(x=(beta_ld), y=(bhj))) + geom_point() + geom_abline() + facet_grid(j ~ .)\n\n\n\n\n\n\n\n\n\n\n\n---\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsessionInfo()\n```\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}